import "./chunk-X6RQY52Q.js";
import {
  fade
} from "./chunk-IBBFM7U6.js";
import "./chunk-VFRMSNTO.js";
import {
  writable
} from "./chunk-ZVD53ECP.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  add_flush_callback,
  add_iframe_resize_listener,
  add_location,
  add_render_callback,
  append_dev,
  append_styles,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  component_subscribe,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  handle_promise,
  init,
  insert_dev,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  raf,
  run_all,
  safe_not_equal,
  setContext,
  set_data_dev,
  set_store_value,
  set_style,
  space,
  src_url_equal,
  svg_element,
  text,
  time_ranges_to_array,
  toggle_class,
  transition_in,
  transition_out,
  update_await_block_branch,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-DHUVRBJZ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-Y3B6BDQS.js";

// node_modules/svelte-video-player/src/libs/screenfull.js
var require_screenfull = __commonJS({
  "node_modules/svelte-video-player/src/libs/screenfull.js"(exports, module) {
    (function() {
      "use strict";
      var document2 = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.document : {};
      var isCommonjs = typeof module !== "undefined" && module.exports;
      var fn = function() {
        var val;
        var fnMap = [
          [
            "requestFullscreen",
            "exitFullscreen",
            "fullscreenElement",
            "fullscreenEnabled",
            "fullscreenchange",
            "fullscreenerror"
          ],
          // New WebKit
          [
            "webkitRequestFullscreen",
            "webkitExitFullscreen",
            "webkitFullscreenElement",
            "webkitFullscreenEnabled",
            "webkitfullscreenchange",
            "webkitfullscreenerror"
          ],
          // Old WebKit
          [
            "webkitRequestFullScreen",
            "webkitCancelFullScreen",
            "webkitCurrentFullScreenElement",
            "webkitCancelFullScreen",
            "webkitfullscreenchange",
            "webkitfullscreenerror"
          ],
          [
            "mozRequestFullScreen",
            "mozCancelFullScreen",
            "mozFullScreenElement",
            "mozFullScreenEnabled",
            "mozfullscreenchange",
            "mozfullscreenerror"
          ],
          [
            "msRequestFullscreen",
            "msExitFullscreen",
            "msFullscreenElement",
            "msFullscreenEnabled",
            "MSFullscreenChange",
            "MSFullscreenError"
          ]
        ];
        var i = 0;
        var l = fnMap.length;
        var ret = {};
        for (; i < l; i++) {
          val = fnMap[i];
          if (val && val[1] in document2) {
            for (i = 0; i < val.length; i++) {
              ret[fnMap[0][i]] = val[i];
            }
            return ret;
          }
        }
        return false;
      }();
      var eventNameMap = {
        change: fn.fullscreenchange,
        error: fn.fullscreenerror
      };
      var screenfull2 = {
        request(element2, options) {
          return new Promise(
            (function(resolve, reject) {
              var onFullScreenEntered = (function() {
                this.off("change", onFullScreenEntered);
                resolve();
              }).bind(this);
              this.on("change", onFullScreenEntered);
              element2 = element2 || document2.documentElement;
              var returnPromise = element2[fn.requestFullscreen](options);
              if (returnPromise instanceof Promise) {
                returnPromise.then(onFullScreenEntered).catch(reject);
              }
            }).bind(this)
          );
        },
        exit() {
          return new Promise(
            (function(resolve, reject) {
              if (!this.isFullscreen) {
                resolve();
                return;
              }
              var onFullScreenExit = (function() {
                this.off("change", onFullScreenExit);
                resolve();
              }).bind(this);
              this.on("change", onFullScreenExit);
              var returnPromise = document2[fn.exitFullscreen]();
              if (returnPromise instanceof Promise) {
                returnPromise.then(onFullScreenExit).catch(reject);
              }
            }).bind(this)
          );
        },
        toggle(element2, options) {
          return this.isFullscreen ? this.exit() : this.request(element2, options);
        },
        onchange(callback) {
          this.on("change", callback);
        },
        onerror(callback) {
          this.on("error", callback);
        },
        on(event, callback) {
          var eventName = eventNameMap[event];
          if (eventName) {
            document2.addEventListener(eventName, callback, false);
          }
        },
        off(event, callback) {
          var eventName = eventNameMap[event];
          if (eventName) {
            document2.removeEventListener(eventName, callback, false);
          }
        },
        raw: fn
      };
      if (!fn) {
        if (isCommonjs) {
          module.exports = { isEnabled: false };
        } else {
          window.screenfull = { isEnabled: false };
        }
        return;
      }
      Object.defineProperties(screenfull2, {
        isFullscreen: {
          get: function() {
            return Boolean(document2[fn.fullscreenElement]);
          }
        },
        element: {
          enumerable: true,
          get: function() {
            return document2[fn.fullscreenElement];
          }
        },
        isEnabled: {
          enumerable: true,
          get: function() {
            return Boolean(document2[fn.fullscreenEnabled]);
          }
        }
      });
      if (isCommonjs) {
        module.exports = screenfull2;
      } else {
        window.screenfull = screenfull2;
      }
    })();
  }
});

// node_modules/svelte-video-player/src/utils.js
function extensionToMimeType(filename) {
  const mimes = { mp4: "video/mp4", ogv: "video/ogg", webm: "video/webm" };
  const ext = (filename.match(/\.([^.]*?)(?=\?|#|$)/) || [])[1];
  if (ext in mimes)
    return mimes[ext];
  return;
}
function prepareVideoSources(source) {
  let sources;
  if (!source) {
    sources = [];
  } else if (source instanceof Array) {
    sources = source.map((item) => {
      const type = extensionToMimeType(item);
      return typeof type === "undefined" ? { src: item } : { src: item, type };
    }).filter((item) => item);
  } else {
    const type = extensionToMimeType(source);
    sources = typeof type === "undefined" ? [{ src: source }] : [{ src: source, type }];
  }
  return sources;
}
function uid() {
  var firstPart = Math.random() * 46656 | 0;
  var secondPart = Math.random() * 46656 | 0;
  firstPart = ("000" + firstPart.toString(36)).slice(-3);
  secondPart = ("000" + secondPart.toString(36)).slice(-3);
  return firstPart + secondPart;
}
async function preloadImage(url) {
  return new Promise((resolve, reject) => {
    if (url) {
      const image = new Image();
      image.addEventListener(
        "load",
        () => {
          resolve(image);
        },
        { once: true }
      );
      image.addEventListener(
        "error",
        () => {
          resolve();
        },
        { once: true }
      );
      image.src = url;
    } else {
      resolve();
    }
  });
}

// node_modules/svelte-video-player/src/Poster.svelte
var file = "node_modules/svelte-video-player/src/Poster.svelte";
function add_css(target) {
  append_styles(target, "svelte-fde6bj", ".poster.svelte-fde6bj{position:absolute;top:0;left:0;width:100%;height:100%;object-fit:cover}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUG9zdGVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFLRSxxQkFBUSxDQUNOLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLENBQUMsQ0FDUCxLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBQ1osVUFBVSxDQUFFLEtBQ2QiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiUG9zdGVyLnN2ZWx0ZSJdfQ== */");
}
function create_fragment(ctx) {
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      img = element("img");
      if (!src_url_equal(img.src, img_src_value = /*src*/
      ctx[0]))
        attr_dev(img, "src", img_src_value);
      attr_dev(img, "class", "poster svelte-fde6bj");
      attr_dev(img, "alt", "poster");
      attr_dev(img, "onerror", "this.style.display='none'");
      add_location(img, file, 15, 0, 194);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*src*/
      1 && !src_url_equal(img.src, img_src_value = /*src*/
      ctx2[0])) {
        attr_dev(img, "src", img_src_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(img);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Poster", slots, []);
  let { src } = $$props;
  $$self.$$.on_mount.push(function() {
    if (src === void 0 && !("src" in $$props || $$self.$$.bound[$$self.$$.props["src"]])) {
      console.warn("<Poster> was created without expected prop 'src'");
    }
  });
  const writable_props = ["src"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Poster> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("src" in $$props2)
      $$invalidate(0, src = $$props2.src);
  };
  $$self.$capture_state = () => ({ src });
  $$self.$inject_state = ($$props2) => {
    if ("src" in $$props2)
      $$invalidate(0, src = $$props2.src);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [src];
}
var Poster = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { src: 0 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Poster",
      options,
      id: create_fragment.name
    });
  }
  get src() {
    throw new Error("<Poster>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<Poster>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Poster_default = Poster;

// node_modules/svelte-video-player/src/Controls.svelte
var file2 = "node_modules/svelte-video-player/src/Controls.svelte";
function add_css2(target) {
  append_styles(target, "svelte-h6eqmh", ".overlay.svelte-h6eqmh{z-index:2147483647;position:absolute;width:100%;height:100%;top:0;left:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udHJvbHMuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQUNFLHNCQUFTLENBQ1AsT0FBTyxDQUFFLFVBQVUsQ0FDbkIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLEdBQUcsQ0FBRSxDQUFDLENBQ04sSUFBSSxDQUFFLENBQ1IiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQ29udHJvbHMuc3ZlbHRlIl19 */");
}
function create_fragment2(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "overlay svelte-h6eqmh");
      add_location(div, file2, 11, 0, 155);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Controls", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Controls> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Controls = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {}, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Controls",
      options,
      id: create_fragment2.name
    });
  }
};
var Controls_default = Controls;

// node_modules/svelte-video-player/src/PlayPauseIcon.svelte
var file3 = "node_modules/svelte-video-player/src/PlayPauseIcon.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1na3hbp", ".play-pause-icon.svelte-1na3hbp{position:absolute}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGxheVBhdXNlSWNvbi5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBV0UsK0JBQWlCLENBQ2YsUUFBUSxDQUFFLFFBQ1oiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiUGxheVBhdXNlSWNvbi5zdmVsdGUiXX0= */");
}
function create_fragment3(ctx) {
  let div;
  let svg;
  let path0;
  let path0_visibility_value;
  let path0_stroke_value;
  let path1;
  let path1_visibility_value;
  let path1_fill_value;
  let path1_stroke_value;
  const block = {
    c: function create() {
      div = element("div");
      svg = svg_element("svg");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr_dev(path0, "visibility", path0_visibility_value = !/*paused*/
      ctx[2] ? "visible" : "hidden");
      attr_dev(path0, "d", "M40 29v42M60 29v42");
      attr_dev(path0, "stroke", path0_stroke_value = /*$cfg*/
      ctx[3].iconColor);
      attr_dev(path0, "stroke-width", "5");
      add_location(path0, file3, 22, 4, 426);
      attr_dev(path1, "visibility", path1_visibility_value = /*paused*/
      ctx[2] ? "visible" : "hidden");
      attr_dev(path1, "d", "M40 29v42l26-21-26-21z");
      attr_dev(path1, "fill", path1_fill_value = /*filled*/
      ctx[1] ? (
        /*$cfg*/
        ctx[3].iconColor
      ) : "none");
      attr_dev(path1, "stroke", path1_stroke_value = /*$cfg*/
      ctx[3].iconColor);
      attr_dev(path1, "stroke-width", "5");
      add_location(path1, file3, 27, 4, 576);
      attr_dev(svg, "viewBox", "0 0 100 100");
      attr_dev(svg, "width", "100%");
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      add_location(svg, file3, 17, 2, 313);
      attr_dev(div, "class", "play-pause-icon svelte-1na3hbp");
      set_style(
        div,
        "width",
        /*size*/
        ctx[0]
      );
      add_location(div, file3, 16, 0, 258);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, svg);
      append_dev(svg, path0);
      append_dev(svg, path1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*paused*/
      4 && path0_visibility_value !== (path0_visibility_value = !/*paused*/
      ctx2[2] ? "visible" : "hidden")) {
        attr_dev(path0, "visibility", path0_visibility_value);
      }
      if (dirty & /*$cfg*/
      8 && path0_stroke_value !== (path0_stroke_value = /*$cfg*/
      ctx2[3].iconColor)) {
        attr_dev(path0, "stroke", path0_stroke_value);
      }
      if (dirty & /*paused*/
      4 && path1_visibility_value !== (path1_visibility_value = /*paused*/
      ctx2[2] ? "visible" : "hidden")) {
        attr_dev(path1, "visibility", path1_visibility_value);
      }
      if (dirty & /*filled, $cfg*/
      10 && path1_fill_value !== (path1_fill_value = /*filled*/
      ctx2[1] ? (
        /*$cfg*/
        ctx2[3].iconColor
      ) : "none")) {
        attr_dev(path1, "fill", path1_fill_value);
      }
      if (dirty & /*$cfg*/
      8 && path1_stroke_value !== (path1_stroke_value = /*$cfg*/
      ctx2[3].iconColor)) {
        attr_dev(path1, "stroke", path1_stroke_value);
      }
      if (dirty & /*size*/
      1) {
        set_style(
          div,
          "width",
          /*size*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $cfg;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PlayPauseIcon", slots, []);
  let { size = "100%" } = $$props;
  let { filled = false } = $$props;
  let { paused } = $$props;
  const cfg = getContext("config");
  validate_store(cfg, "cfg");
  component_subscribe($$self, cfg, (value) => $$invalidate(3, $cfg = value));
  $$self.$$.on_mount.push(function() {
    if (paused === void 0 && !("paused" in $$props || $$self.$$.bound[$$self.$$.props["paused"]])) {
      console.warn("<PlayPauseIcon> was created without expected prop 'paused'");
    }
  });
  const writable_props = ["size", "filled", "paused"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PlayPauseIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("filled" in $$props2)
      $$invalidate(1, filled = $$props2.filled);
    if ("paused" in $$props2)
      $$invalidate(2, paused = $$props2.paused);
  };
  $$self.$capture_state = () => ({
    getContext,
    size,
    filled,
    paused,
    cfg,
    $cfg
  });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("filled" in $$props2)
      $$invalidate(1, filled = $$props2.filled);
    if ("paused" in $$props2)
      $$invalidate(2, paused = $$props2.paused);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, filled, paused, $cfg, cfg];
}
var PlayPauseIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { size: 0, filled: 1, paused: 2 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PlayPauseIcon",
      options,
      id: create_fragment3.name
    });
  }
  get size() {
    throw new Error("<PlayPauseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<PlayPauseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filled() {
    throw new Error("<PlayPauseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filled(value) {
    throw new Error("<PlayPauseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get paused() {
    throw new Error("<PlayPauseIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set paused(value) {
    throw new Error("<PlayPauseIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PlayPauseIcon_default = PlayPauseIcon;

// node_modules/svelte-video-player/src/PlayIconCenter.svelte
var file4 = "node_modules/svelte-video-player/src/PlayIconCenter.svelte";
function add_css4(target) {
  append_styles(target, "svelte-1yuiuyr", ".player-icon.svelte-1yuiuyr{box-sizing:border-box;position:relative;width:100%;height:100%;border-style:none;border-radius:9999px;border-width:2px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGxheUljb25DZW50ZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQVdFLDJCQUFhLENBQ1gsVUFBVSxDQUFFLFVBQVUsQ0FDdEIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLFlBQVksQ0FBRSxJQUFJLENBQ2xCLGFBQWEsQ0FBRSxNQUFNLENBQ3JCLFlBQVksQ0FBRSxHQUNoQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJQbGF5SWNvbkNlbnRlci5zdmVsdGUiXX0= */");
}
function create_if_block(ctx) {
  let div;
  let playpauseicon;
  let div_transition;
  let current;
  playpauseicon = new PlayPauseIcon_default({ props: { paused: true }, $$inline: true });
  const block = {
    c: function create() {
      div = element("div");
      create_component(playpauseicon.$$.fragment);
      attr_dev(div, "class", "player-icon svelte-1yuiuyr");
      set_style(
        div,
        "background-color",
        /*$cfg*/
        ctx[1].color
      );
      set_style(
        div,
        "border-color",
        /*$cfg*/
        ctx[1].focusColor
      );
      add_location(div, file4, 23, 2, 455);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(playpauseicon, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*$cfg*/
      2) {
        set_style(
          div,
          "background-color",
          /*$cfg*/
          ctx2[1].color
        );
      }
      if (!current || dirty & /*$cfg*/
      2) {
        set_style(
          div,
          "border-color",
          /*$cfg*/
          ctx2[1].focusColor
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(playpauseicon.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, fade, { duration: 500 }, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(playpauseicon.$$.fragment, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, fade, { duration: 500 }, false);
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(playpauseicon);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(23:0) {#if !hidden}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*hidden*/
  ctx[0] && create_if_block(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!/*hidden*/
      ctx2[0]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*hidden*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let $cfg;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PlayIconCenter", slots, []);
  let { hidden } = $$props;
  const cfg = getContext("config");
  validate_store(cfg, "cfg");
  component_subscribe($$self, cfg, (value) => $$invalidate(1, $cfg = value));
  $$self.$$.on_mount.push(function() {
    if (hidden === void 0 && !("hidden" in $$props || $$self.$$.bound[$$self.$$.props["hidden"]])) {
      console.warn("<PlayIconCenter> was created without expected prop 'hidden'");
    }
  });
  const writable_props = ["hidden"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PlayIconCenter> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("hidden" in $$props2)
      $$invalidate(0, hidden = $$props2.hidden);
  };
  $$self.$capture_state = () => ({
    getContext,
    fade,
    PlayPauseIcon: PlayPauseIcon_default,
    hidden,
    cfg,
    $cfg
  });
  $$self.$inject_state = ($$props2) => {
    if ("hidden" in $$props2)
      $$invalidate(0, hidden = $$props2.hidden);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [hidden, $cfg, cfg];
}
var PlayIconCenter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { hidden: 0 }, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PlayIconCenter",
      options,
      id: create_fragment4.name
    });
  }
  get hidden() {
    throw new Error("<PlayIconCenter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<PlayIconCenter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PlayIconCenter_default = PlayIconCenter;

// node_modules/svelte-video-player/src/Spinner.svelte
var file5 = "node_modules/svelte-video-player/src/Spinner.svelte";
function add_css5(target) {
  append_styles(target, "svelte-1q5dh4a", ".spinner.svelte-1q5dh4a{position:absolute;left:50%;top:50%;transform:translate(-50%, -50%)}.circle.svelte-1q5dh4a{box-sizing:border-box;position:absolute;height:100%;width:100%;border-width:2px;border-style:solid;border-radius:50%}.bg.svelte-1q5dh4a{opacity:0.25}.rotating.svelte-1q5dh4a{animation:1s linear 0s infinite normal none running svelte-1q5dh4a-rotate}@keyframes svelte-1q5dh4a-rotate{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3Bpbm5lci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBU0UsdUJBQVMsQ0FDUCxRQUFRLENBQUUsUUFBUSxDQUNsQixJQUFJLENBQUUsR0FBRyxDQUNULEdBQUcsQ0FBRSxHQUFHLENBQ1IsU0FBUyxDQUFFLFVBQVUsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUNqQyxDQUVBLHNCQUFRLENBQ04sVUFBVSxDQUFFLFVBQVUsQ0FDdEIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsTUFBTSxDQUFFLElBQUksQ0FDWixLQUFLLENBQUUsSUFBSSxDQUNYLFlBQVksQ0FBRSxHQUFHLENBQ2pCLFlBQVksQ0FBRSxLQUFLLENBQ25CLGFBQWEsQ0FBRSxHQUNqQixDQUVBLGtCQUFJLENBQ0YsT0FBTyxDQUFFLElBQ1gsQ0FFQSx3QkFBVSxDQUNSLFNBQVMsQ0FBRSxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMscUJBQ3ZELENBRUEsV0FBVyxxQkFBTyxDQUNoQixFQUFHLENBQ0QsU0FBUyxDQUFFLE9BQU8sQ0FBQyxDQUNyQixDQUNBLElBQUssQ0FDSCxTQUFTLENBQUUsT0FBTyxNQUFNLENBQzFCLENBQ0YiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiU3Bpbm5lci5zdmVsdGUiXX0= */");
}
function create_if_block2(ctx) {
  let div2;
  let div0;
  let t;
  let div1;
  let div2_intro;
  let div2_outro;
  let current;
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t = space();
      div1 = element("div");
      attr_dev(div0, "class", "circle bg svelte-1q5dh4a");
      set_style(
        div0,
        "border-color",
        /*color*/
        ctx[1]
      );
      add_location(div0, file5, 50, 4, 903);
      attr_dev(div1, "class", "circle rotating svelte-1q5dh4a");
      set_style(
        div1,
        "border-color",
        /*color*/
        ctx[1] + " " + /*color*/
        ctx[1] + " transparent transparent"
      );
      add_location(div1, file5, 51, 4, 964);
      attr_dev(div2, "class", "spinner svelte-1q5dh4a");
      set_style(
        div2,
        "width",
        /*size*/
        ctx[0]
      );
      set_style(
        div2,
        "height",
        /*size*/
        ctx[0]
      );
      add_location(div2, file5, 45, 2, 750);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div0);
      append_dev(div2, t);
      append_dev(div2, div1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & /*color*/
      2) {
        set_style(
          div0,
          "border-color",
          /*color*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*color*/
      2) {
        set_style(
          div1,
          "border-color",
          /*color*/
          ctx2[1] + " " + /*color*/
          ctx2[1] + " transparent transparent"
        );
      }
      if (!current || dirty & /*size*/
      1) {
        set_style(
          div2,
          "width",
          /*size*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*size*/
      1) {
        set_style(
          div2,
          "height",
          /*size*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div2_outro)
            div2_outro.end(1);
          div2_intro = create_in_transition(div2, fade, { delay: 500, duration: 500 });
          div2_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (div2_intro)
        div2_intro.invalidate();
      if (local) {
        div2_outro = create_out_transition(div2, fade, { duration: 100 });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (detaching && div2_outro)
        div2_outro.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(45:0) {#if !hidden}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let if_block_anchor;
  let if_block = !/*hidden*/
  ctx[2] && create_if_block2(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (!/*hidden*/
      ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*hidden*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      transition_in(if_block);
    },
    o: function outro(local) {
      transition_out(if_block);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Spinner", slots, []);
  let { size = "60px" } = $$props;
  let { color = "#FFF" } = $$props;
  let { hidden = false } = $$props;
  const writable_props = ["size", "color", "hidden"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Spinner> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(1, color = $$props2.color);
    if ("hidden" in $$props2)
      $$invalidate(2, hidden = $$props2.hidden);
  };
  $$self.$capture_state = () => ({ fade, size, color, hidden });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(1, color = $$props2.color);
    if ("hidden" in $$props2)
      $$invalidate(2, hidden = $$props2.hidden);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, color, hidden];
}
var Spinner = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { size: 0, color: 1, hidden: 2 }, add_css5);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Spinner",
      options,
      id: create_fragment5.name
    });
  }
  get size() {
    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hidden() {
    throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Spinner_default = Spinner;

// node_modules/svelte-video-player/src/CenterIcons.svelte
var file6 = "node_modules/svelte-video-player/src/CenterIcons.svelte";
function add_css6(target) {
  append_styles(target, "svelte-1s6qb6f", ".center-icons.svelte-1s6qb6f{position:absolute;width:100%;height:100%;left:50%;top:50%;transform:translate(-50%, -50%)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2VudGVySWNvbnMuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWdCRSw0QkFBYyxDQUNaLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixJQUFJLENBQUUsR0FBRyxDQUNULEdBQUcsQ0FBRSxHQUFHLENBQ1IsU0FBUyxDQUFFLFVBQVUsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUNqQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDZW50ZXJJY29ucy5zdmVsdGUiXX0= */");
}
function create_fragment6(ctx) {
  let div;
  let playiconcenter;
  let t;
  let spinner;
  let div_resize_listener;
  let current;
  playiconcenter = new PlayIconCenter_default({
    props: { hidden: !/*isIconVisible*/
    ctx[2] },
    $$inline: true
  });
  spinner = new Spinner_default({
    props: {
      hidden: !/*isSpinnerVisible*/
      ctx[1],
      color: (
        /*isBuffering*/
        ctx[0] ? (
          /*$cfg*/
          ctx[4].color
        ) : (
          /*$cfg*/
          ctx[4].iconColor
        )
      ),
      size: (
        /*offsetWidth*/
        ctx[3] + 10 + "px"
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(playiconcenter.$$.fragment);
      t = space();
      create_component(spinner.$$.fragment);
      attr_dev(div, "class", "center-icons svelte-1s6qb6f");
      set_style(
        div,
        "width",
        /*$cfg*/
        ctx[4].centerIconSize
      );
      set_style(
        div,
        "height",
        /*$cfg*/
        ctx[4].centerIconSize
      );
      add_render_callback(() => (
        /*div_elementresize_handler*/
        ctx[6].call(div)
      ));
      add_location(div, file6, 26, 0, 493);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(playiconcenter, div, null);
      append_dev(div, t);
      mount_component(spinner, div, null);
      div_resize_listener = add_iframe_resize_listener(
        div,
        /*div_elementresize_handler*/
        ctx[6].bind(div)
      );
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const playiconcenter_changes = {};
      if (dirty & /*isIconVisible*/
      4)
        playiconcenter_changes.hidden = !/*isIconVisible*/
        ctx2[2];
      playiconcenter.$set(playiconcenter_changes);
      const spinner_changes = {};
      if (dirty & /*isSpinnerVisible*/
      2)
        spinner_changes.hidden = !/*isSpinnerVisible*/
        ctx2[1];
      if (dirty & /*isBuffering, $cfg*/
      17)
        spinner_changes.color = /*isBuffering*/
        ctx2[0] ? (
          /*$cfg*/
          ctx2[4].color
        ) : (
          /*$cfg*/
          ctx2[4].iconColor
        );
      if (dirty & /*offsetWidth*/
      8)
        spinner_changes.size = /*offsetWidth*/
        ctx2[3] + 10 + "px";
      spinner.$set(spinner_changes);
      if (!current || dirty & /*$cfg*/
      16) {
        set_style(
          div,
          "width",
          /*$cfg*/
          ctx2[4].centerIconSize
        );
      }
      if (!current || dirty & /*$cfg*/
      16) {
        set_style(
          div,
          "height",
          /*$cfg*/
          ctx2[4].centerIconSize
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(playiconcenter.$$.fragment, local);
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(playiconcenter.$$.fragment, local);
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(playiconcenter);
      destroy_component(spinner);
      div_resize_listener();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let $cfg;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CenterIcons", slots, []);
  let { isBuffering } = $$props;
  let { isSpinnerVisible } = $$props;
  let { isIconVisible } = $$props;
  let offsetWidth;
  const cfg = getContext("config");
  validate_store(cfg, "cfg");
  component_subscribe($$self, cfg, (value) => $$invalidate(4, $cfg = value));
  $$self.$$.on_mount.push(function() {
    if (isBuffering === void 0 && !("isBuffering" in $$props || $$self.$$.bound[$$self.$$.props["isBuffering"]])) {
      console.warn("<CenterIcons> was created without expected prop 'isBuffering'");
    }
    if (isSpinnerVisible === void 0 && !("isSpinnerVisible" in $$props || $$self.$$.bound[$$self.$$.props["isSpinnerVisible"]])) {
      console.warn("<CenterIcons> was created without expected prop 'isSpinnerVisible'");
    }
    if (isIconVisible === void 0 && !("isIconVisible" in $$props || $$self.$$.bound[$$self.$$.props["isIconVisible"]])) {
      console.warn("<CenterIcons> was created without expected prop 'isIconVisible'");
    }
  });
  const writable_props = ["isBuffering", "isSpinnerVisible", "isIconVisible"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<CenterIcons> was created with unknown prop '${key}'`);
  });
  function div_elementresize_handler() {
    offsetWidth = this.offsetWidth;
    $$invalidate(3, offsetWidth);
  }
  $$self.$$set = ($$props2) => {
    if ("isBuffering" in $$props2)
      $$invalidate(0, isBuffering = $$props2.isBuffering);
    if ("isSpinnerVisible" in $$props2)
      $$invalidate(1, isSpinnerVisible = $$props2.isSpinnerVisible);
    if ("isIconVisible" in $$props2)
      $$invalidate(2, isIconVisible = $$props2.isIconVisible);
  };
  $$self.$capture_state = () => ({
    getContext,
    PlayIconCenter: PlayIconCenter_default,
    Spinner: Spinner_default,
    isBuffering,
    isSpinnerVisible,
    isIconVisible,
    offsetWidth,
    cfg,
    $cfg
  });
  $$self.$inject_state = ($$props2) => {
    if ("isBuffering" in $$props2)
      $$invalidate(0, isBuffering = $$props2.isBuffering);
    if ("isSpinnerVisible" in $$props2)
      $$invalidate(1, isSpinnerVisible = $$props2.isSpinnerVisible);
    if ("isIconVisible" in $$props2)
      $$invalidate(2, isIconVisible = $$props2.isIconVisible);
    if ("offsetWidth" in $$props2)
      $$invalidate(3, offsetWidth = $$props2.offsetWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    isBuffering,
    isSpinnerVisible,
    isIconVisible,
    offsetWidth,
    $cfg,
    cfg,
    div_elementresize_handler
  ];
}
var CenterIcons = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        isBuffering: 0,
        isSpinnerVisible: 1,
        isIconVisible: 2
      },
      add_css6
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CenterIcons",
      options,
      id: create_fragment6.name
    });
  }
  get isBuffering() {
    throw new Error("<CenterIcons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isBuffering(value) {
    throw new Error("<CenterIcons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isSpinnerVisible() {
    throw new Error("<CenterIcons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isSpinnerVisible(value) {
    throw new Error("<CenterIcons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isIconVisible() {
    throw new Error("<CenterIcons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isIconVisible(value) {
    throw new Error("<CenterIcons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CenterIcons_default = CenterIcons;

// node_modules/svelte-video-player/src/BottomControls.svelte
var file7 = "node_modules/svelte-video-player/src/BottomControls.svelte";
function add_css7(target) {
  append_styles(target, "svelte-do64tg", ".controls.svelte-do64tg{position:relative;box-sizing:border-box;min-height:40px;max-height:150px;top:100%;transform:translateY(-100%);padding:10px;display:flex;gap:6px;visibility:visible;transition:transform 0.5s ease, visibility 0.5s linear}.hidden.svelte-do64tg{visibility:hidden;transform:translateY(100%)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQm90dG9tQ29udHJvbHMuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQStCRSx1QkFBVSxDQUNSLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLFVBQVUsQ0FBRSxVQUFVLENBQ3RCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLFVBQVUsQ0FBRSxLQUFLLENBQ2pCLEdBQUcsQ0FBRSxJQUFJLENBQ1QsU0FBUyxDQUFFLFdBQVcsS0FBSyxDQUFDLENBQzVCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsT0FBTyxDQUFFLElBQUksQ0FDYixHQUFHLENBQUUsR0FBRyxDQUNSLFVBQVUsQ0FBRSxPQUFPLENBQ25CLFVBQVUsQ0FBRSxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFDbkQsQ0FFQSxxQkFBUSxDQUNOLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLFNBQVMsQ0FBRSxXQUFXLElBQUksQ0FDNUIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiQm90dG9tQ29udHJvbHMuc3ZlbHRlIl19 */");
}
function create_fragment7(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "controls svelte-do64tg");
      set_style(
        div,
        "height",
        /*$cfg*/
        ctx[2].controlsHeight
      );
      set_style(div, "background", "linear-gradient(rgba(0,0,0,0), rgba(0,0,0,.2) 80%)");
      toggle_class(
        div,
        "hidden",
        /*hidden*/
        ctx[0]
      );
      add_location(div, file7, 55, 0, 1181);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "pointermove",
            /*pointermove_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "keydown",
            /*keydown_handler*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "pointerover",
            /*onPointerOver*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "pointerout",
            /*onPointerOut*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "transitionend",
            /*onTransitionEnd*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$cfg*/
      4) {
        set_style(
          div,
          "height",
          /*$cfg*/
          ctx2[2].controlsHeight
        );
      }
      if (!current || dirty & /*hidden*/
      1) {
        toggle_class(
          div,
          "hidden",
          /*hidden*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let $cfg;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BottomControls", slots, ["default"]);
  let { hidden } = $$props;
  let { isPointerOver } = $$props;
  const cfg = getContext("config");
  validate_store(cfg, "cfg");
  component_subscribe($$self, cfg, (value) => $$invalidate(2, $cfg = value));
  let lastFocusElement;
  let wasTabDown;
  function onPointerOver(e) {
    $$invalidate(7, isPointerOver = true);
  }
  function onPointerOut(e) {
    $$invalidate(7, isPointerOver = false);
  }
  function onTransitionEnd(e) {
    if (e.propertyName == "visibility") {
      if (!hidden && wasTabDown) {
        lastFocusElement.focus({ preventScroll: true });
      } else {
        lastFocusElement = document.activeElement;
      }
    }
  }
  $$self.$$.on_mount.push(function() {
    if (hidden === void 0 && !("hidden" in $$props || $$self.$$.bound[$$self.$$.props["hidden"]])) {
      console.warn("<BottomControls> was created without expected prop 'hidden'");
    }
    if (isPointerOver === void 0 && !("isPointerOver" in $$props || $$self.$$.bound[$$self.$$.props["isPointerOver"]])) {
      console.warn("<BottomControls> was created without expected prop 'isPointerOver'");
    }
  });
  const writable_props = ["hidden", "isPointerOver"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BottomControls> was created with unknown prop '${key}'`);
  });
  const pointermove_handler = () => $$invalidate(1, wasTabDown = false);
  const keydown_handler = (e) => $$invalidate(1, wasTabDown = e.code === "Tab");
  $$self.$$set = ($$props2) => {
    if ("hidden" in $$props2)
      $$invalidate(0, hidden = $$props2.hidden);
    if ("isPointerOver" in $$props2)
      $$invalidate(7, isPointerOver = $$props2.isPointerOver);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    hidden,
    isPointerOver,
    cfg,
    lastFocusElement,
    wasTabDown,
    onPointerOver,
    onPointerOut,
    onTransitionEnd,
    $cfg
  });
  $$self.$inject_state = ($$props2) => {
    if ("hidden" in $$props2)
      $$invalidate(0, hidden = $$props2.hidden);
    if ("isPointerOver" in $$props2)
      $$invalidate(7, isPointerOver = $$props2.isPointerOver);
    if ("lastFocusElement" in $$props2)
      lastFocusElement = $$props2.lastFocusElement;
    if ("wasTabDown" in $$props2)
      $$invalidate(1, wasTabDown = $$props2.wasTabDown);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    hidden,
    wasTabDown,
    $cfg,
    cfg,
    onPointerOver,
    onPointerOut,
    onTransitionEnd,
    isPointerOver,
    $$scope,
    slots,
    pointermove_handler,
    keydown_handler
  ];
}
var BottomControls = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { hidden: 0, isPointerOver: 7 }, add_css7);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BottomControls",
      options,
      id: create_fragment7.name
    });
  }
  get hidden() {
    throw new Error("<BottomControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hidden(value) {
    throw new Error("<BottomControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isPointerOver() {
    throw new Error("<BottomControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isPointerOver(value) {
    throw new Error("<BottomControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BottomControls_default = BottomControls;

// node_modules/svelte-video-player/src/libs/throttle.js
function throttle(fn, interval, callFirst) {
  var wait = false;
  var callNow = false;
  return function() {
    callNow = callFirst && !wait;
    var context = this;
    var args = arguments;
    if (!wait) {
      wait = true;
      setTimeout(function() {
        wait = false;
        if (!callFirst) {
          return fn.apply(context, args);
        }
      }, interval);
    }
    if (callNow) {
      callNow = false;
      return fn.apply(this, arguments);
    }
  };
}

// node_modules/svelte-video-player/src/Bar.svelte
var file8 = "node_modules/svelte-video-player/src/Bar.svelte";
function add_css8(target) {
  append_styles(target, "svelte-1539bnd", ".bar.svelte-1539bnd{position:absolute;top:0;width:100%;height:100%;transform-origin:0 0;border-style:solid;border-width:1px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmFyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFPRSxtQkFBSyxDQUNILFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLGdCQUFnQixDQUFFLENBQUMsQ0FBQyxDQUFDLENBQ3JCLFlBQVksQ0FBRSxLQUFLLENBQ25CLFlBQVksQ0FBRSxHQUNoQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJCYXIuc3ZlbHRlIl19 */");
}
function create_fragment8(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "bar svelte-1539bnd");
      set_style(
        div,
        "background-color",
        /*color*/
        ctx[0]
      );
      set_style(
        div,
        "border-color",
        /*color*/
        ctx[0]
      );
      set_style(
        div,
        "opacity",
        /*opacity*/
        ctx[1]
      );
      set_style(div, "transform", "scaleX(" + /*value*/
      ctx[2] + ")");
      add_location(div, file8, 18, 0, 295);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*color*/
      1) {
        set_style(
          div,
          "background-color",
          /*color*/
          ctx2[0]
        );
      }
      if (dirty & /*color*/
      1) {
        set_style(
          div,
          "border-color",
          /*color*/
          ctx2[0]
        );
      }
      if (dirty & /*opacity*/
      2) {
        set_style(
          div,
          "opacity",
          /*opacity*/
          ctx2[1]
        );
      }
      if (dirty & /*value*/
      4) {
        set_style(div, "transform", "scaleX(" + /*value*/
        ctx2[2] + ")");
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Bar", slots, []);
  let { color = "white" } = $$props;
  let { opacity = 1 } = $$props;
  let { value = 0 } = $$props;
  const writable_props = ["color", "opacity", "value"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Bar> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(0, color = $$props2.color);
    if ("opacity" in $$props2)
      $$invalidate(1, opacity = $$props2.opacity);
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
  };
  $$self.$capture_state = () => ({ color, opacity, value });
  $$self.$inject_state = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(0, color = $$props2.color);
    if ("opacity" in $$props2)
      $$invalidate(1, opacity = $$props2.opacity);
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [color, opacity, value];
}
var Bar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { color: 0, opacity: 1, value: 2 }, add_css8);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Bar",
      options,
      id: create_fragment8.name
    });
  }
  get color() {
    throw new Error("<Bar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Bar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<Bar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<Bar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Bar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Bar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Bar_default = Bar;

// node_modules/svelte-video-player/src/Chunkbar.svelte
var file9 = "node_modules/svelte-video-player/src/Chunkbar.svelte";
function add_css9(target) {
  append_styles(target, "svelte-mhutnt", ".chunk-bar.svelte-mhutnt{position:absolute;width:100%;height:100%}.chunk.svelte-mhutnt{position:absolute;width:100%;height:100%;transform-origin:0 0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2h1bmtiYXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQU9FLHdCQUFXLENBQ1QsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFDVixDQUNBLG9CQUFPLENBQ0wsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLGdCQUFnQixDQUFFLENBQUMsQ0FBQyxDQUN0QiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDaHVua2Jhci5zdmVsdGUiXX0= */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "chunk svelte-mhutnt");
      set_style(
        div,
        "background-color",
        /*color*/
        ctx[0]
      );
      set_style(
        div,
        "opacity",
        /*opacity*/
        ctx[1]
      );
      set_style(div, "transform", "translateX(" + /*range*/
      ctx[3].start * 100 + "%) scaleX(" + /*range*/
      (ctx[3].end - /*range*/
      ctx[3].start) + ")");
      add_location(div, file9, 22, 4, 398);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*color*/
      1) {
        set_style(
          div,
          "background-color",
          /*color*/
          ctx2[0]
        );
      }
      if (dirty & /*opacity*/
      2) {
        set_style(
          div,
          "opacity",
          /*opacity*/
          ctx2[1]
        );
      }
      if (dirty & /*ranges*/
      4) {
        set_style(div, "transform", "translateX(" + /*range*/
        ctx2[3].start * 100 + "%) scaleX(" + /*range*/
        (ctx2[3].end - /*range*/
        ctx2[3].start) + ")");
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(22:2) {#each ranges as range}",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let div;
  let each_value = ensure_array_like_dev(
    /*ranges*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "chunk-bar svelte-mhutnt");
      add_location(div, file9, 20, 0, 342);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*color, opacity, ranges*/
      7) {
        each_value = ensure_array_like_dev(
          /*ranges*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Chunkbar", slots, []);
  let { color = "white" } = $$props;
  let { opacity = 1 } = $$props;
  let { ranges = [] } = $$props;
  const writable_props = ["color", "opacity", "ranges"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Chunkbar> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(0, color = $$props2.color);
    if ("opacity" in $$props2)
      $$invalidate(1, opacity = $$props2.opacity);
    if ("ranges" in $$props2)
      $$invalidate(2, ranges = $$props2.ranges);
  };
  $$self.$capture_state = () => ({ color, opacity, ranges });
  $$self.$inject_state = ($$props2) => {
    if ("color" in $$props2)
      $$invalidate(0, color = $$props2.color);
    if ("opacity" in $$props2)
      $$invalidate(1, opacity = $$props2.opacity);
    if ("ranges" in $$props2)
      $$invalidate(2, ranges = $$props2.ranges);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [color, opacity, ranges];
}
var Chunkbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { color: 0, opacity: 1, ranges: 2 }, add_css9);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Chunkbar",
      options,
      id: create_fragment9.name
    });
  }
  get color() {
    throw new Error("<Chunkbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Chunkbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacity() {
    throw new Error("<Chunkbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacity(value) {
    throw new Error("<Chunkbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ranges() {
    throw new Error("<Chunkbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ranges(value) {
    throw new Error("<Chunkbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Chunkbar_default = Chunkbar;

// node_modules/svelte-video-player/src/Thumb.svelte
var file10 = "node_modules/svelte-video-player/src/Thumb.svelte";
function add_css10(target) {
  append_styles(target, "svelte-kj06qu", ".thumb-wrapper.svelte-kj06qu{position:absolute;width:100%;height:100%;top:0;pointer-events:none}.thumb.svelte-kj06qu{position:relative;border-style:none;border-radius:50%;border-width:2px;top:50%;transform:translate(-50%, -50%)}.active.svelte-kj06qu{border-style:solid}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGh1bWIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQVlFLDRCQUFlLENBQ2IsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLEdBQUcsQ0FBRSxDQUFDLENBQ04sY0FBYyxDQUFFLElBQ2xCLENBRUEsb0JBQU8sQ0FDTCxRQUFRLENBQUUsUUFBUSxDQUNsQixZQUFZLENBQUUsSUFBSSxDQUNsQixhQUFhLENBQUUsR0FBRyxDQUNsQixZQUFZLENBQUUsR0FBRyxDQUNqQixHQUFHLENBQUUsR0FBRyxDQUNSLFNBQVMsQ0FBRSxVQUFVLElBQUksQ0FBQyxDQUFDLElBQUksQ0FDakMsQ0FFQSxxQkFBUSxDQUNOLFlBQVksQ0FBRSxLQUNoQiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUaHVtYi5zdmVsdGUiXX0= */");
}
function create_fragment10(ctx) {
  let div1;
  let div0;
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      attr_dev(div0, "class", "thumb svelte-kj06qu");
      set_style(
        div0,
        "width",
        /*$cfg*/
        ctx[2].thumbSize
      );
      set_style(
        div0,
        "height",
        /*$cfg*/
        ctx[2].thumbSize
      );
      set_style(
        div0,
        "background-color",
        /*$cfg*/
        ctx[2].color
      );
      set_style(
        div0,
        "border-color",
        /*$cfg*/
        ctx[2].color
      );
      toggle_class(
        div0,
        "active",
        /*active*/
        ctx[0]
      );
      add_location(div0, file10, 35, 2, 636);
      attr_dev(div1, "class", "thumb-wrapper svelte-kj06qu");
      set_style(div1, "transform", "translateX(" + /*tx*/
      ctx[1] + "%)");
      add_location(div1, file10, 34, 0, 567);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$cfg*/
      4) {
        set_style(
          div0,
          "width",
          /*$cfg*/
          ctx2[2].thumbSize
        );
      }
      if (dirty & /*$cfg*/
      4) {
        set_style(
          div0,
          "height",
          /*$cfg*/
          ctx2[2].thumbSize
        );
      }
      if (dirty & /*$cfg*/
      4) {
        set_style(
          div0,
          "background-color",
          /*$cfg*/
          ctx2[2].color
        );
      }
      if (dirty & /*$cfg*/
      4) {
        set_style(
          div0,
          "border-color",
          /*$cfg*/
          ctx2[2].color
        );
      }
      if (dirty & /*active*/
      1) {
        toggle_class(
          div0,
          "active",
          /*active*/
          ctx2[0]
        );
      }
      if (dirty & /*tx*/
      2) {
        set_style(div1, "transform", "translateX(" + /*tx*/
        ctx2[1] + "%)");
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let tx;
  let $cfg;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Thumb", slots, []);
  let { positionValue = 0 } = $$props;
  let { active = false } = $$props;
  const cfg = getContext("config");
  validate_store(cfg, "cfg");
  component_subscribe($$self, cfg, (value) => $$invalidate(2, $cfg = value));
  const writable_props = ["positionValue", "active"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Thumb> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("positionValue" in $$props2)
      $$invalidate(4, positionValue = $$props2.positionValue);
    if ("active" in $$props2)
      $$invalidate(0, active = $$props2.active);
  };
  $$self.$capture_state = () => ({
    getContext,
    positionValue,
    active,
    cfg,
    tx,
    $cfg
  });
  $$self.$inject_state = ($$props2) => {
    if ("positionValue" in $$props2)
      $$invalidate(4, positionValue = $$props2.positionValue);
    if ("active" in $$props2)
      $$invalidate(0, active = $$props2.active);
    if ("tx" in $$props2)
      $$invalidate(1, tx = $$props2.tx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*positionValue*/
    16) {
      $:
        $$invalidate(1, tx = positionValue * 100);
    }
  };
  return [active, tx, $cfg, cfg, positionValue];
}
var Thumb = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { positionValue: 4, active: 0 }, add_css10);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Thumb",
      options,
      id: create_fragment10.name
    });
  }
  get positionValue() {
    throw new Error("<Thumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set positionValue(value) {
    throw new Error("<Thumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Thumb>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Thumb>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Thumb_default = Thumb;

// node_modules/svelte-video-player/src/Playbar.svelte
var file11 = "node_modules/svelte-video-player/src/Playbar.svelte";
function add_css11(target) {
  append_styles(target, "svelte-wdgqi3", ".playbar.svelte-wdgqi3.svelte-wdgqi3{position:relative;min-width:50px;height:100%;flex-grow:4;cursor:pointer;outline:none;touch-action:none}.playbar.svelte-wdgqi3:focus .bars.svelte-wdgqi3{outline-style:dotted}.bars.svelte-wdgqi3.svelte-wdgqi3{position:relative;width:100%;top:50%;transform:translateY(-50%);border-radius:9999px;overflow:hidden;outline-offset:3px;outline-width:2px;outline-style:none}.chunkbars.svelte-wdgqi3.svelte-wdgqi3{position:absolute;width:100%;height:30%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGxheWJhci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBb0dFLG9DQUFTLENBQ1AsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsU0FBUyxDQUFFLElBQUksQ0FDZixNQUFNLENBQUUsSUFBSSxDQUNaLFNBQVMsQ0FBRSxDQUFDLENBQ1osTUFBTSxDQUFFLE9BQU8sQ0FDZixPQUFPLENBQUUsSUFBSSxDQUNiLFlBQVksQ0FBRSxJQUNoQixDQUVBLHNCQUFRLE1BQU0sQ0FBQyxtQkFBTSxDQUNuQixhQUFhLENBQUUsTUFDakIsQ0FFQSxpQ0FBTSxDQUNKLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxJQUFJLENBQ1gsR0FBRyxDQUFFLEdBQUcsQ0FDUixTQUFTLENBQUUsV0FBVyxJQUFJLENBQUMsQ0FDM0IsYUFBYSxDQUFFLE1BQU0sQ0FDckIsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsY0FBYyxDQUFFLEdBQUcsQ0FDbkIsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsYUFBYSxDQUFFLElBQ2pCLENBRUEsc0NBQVcsQ0FDVCxRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxHQUNWIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlBsYXliYXIuc3ZlbHRlIl19 */");
}
function create_if_block3(ctx) {
  let div;
  let chunkbar0;
  let t;
  let chunkbar1;
  let current;
  chunkbar0 = new Chunkbar_default({
    props: {
      color: (
        /*$cfg*/
        ctx[1].bufferedColor
      ),
      opacity: 1,
      ranges: (
        /*_buffered*/
        ctx[4]
      )
    },
    $$inline: true
  });
  chunkbar1 = new Chunkbar_default({
    props: {
      color: (
        /*$cfg*/
        ctx[1].color
      ),
      opacity: 1,
      ranges: (
        /*_played*/
        ctx[5]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(chunkbar0.$$.fragment);
      t = space();
      create_component(chunkbar1.$$.fragment);
      attr_dev(div, "class", "chunkbars svelte-wdgqi3");
      add_location(div, file11, 147, 6, 3507);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(chunkbar0, div, null);
      append_dev(div, t);
      mount_component(chunkbar1, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const chunkbar0_changes = {};
      if (dirty & /*$cfg*/
      2)
        chunkbar0_changes.color = /*$cfg*/
        ctx2[1].bufferedColor;
      if (dirty & /*_buffered*/
      16)
        chunkbar0_changes.ranges = /*_buffered*/
        ctx2[4];
      chunkbar0.$set(chunkbar0_changes);
      const chunkbar1_changes = {};
      if (dirty & /*$cfg*/
      2)
        chunkbar1_changes.color = /*$cfg*/
        ctx2[1].color;
      if (dirty & /*_played*/
      32)
        chunkbar1_changes.ranges = /*_played*/
        ctx2[5];
      chunkbar1.$set(chunkbar1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(chunkbar0.$$.fragment, local);
      transition_in(chunkbar1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(chunkbar0.$$.fragment, local);
      transition_out(chunkbar1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(chunkbar0);
      destroy_component(chunkbar1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(147:4) {#if $cfg.chunkBars}",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let div1;
  let div0;
  let bar0;
  let t0;
  let bar1;
  let t1;
  let t2;
  let thumb;
  let current;
  let mounted;
  let dispose;
  bar0 = new Bar_default({
    props: {
      color: (
        /*$cfg*/
        ctx[1].barsBgColor
      ),
      opacity: 1,
      value: 1
    },
    $$inline: true
  });
  bar1 = new Bar_default({
    props: {
      color: (
        /*$cfg*/
        ctx[1].color
      ),
      value: (
        /*_currentTimePercentage*/
        ctx[6]
      )
    },
    $$inline: true
  });
  let if_block = (
    /*$cfg*/
    ctx[1].chunkBars && create_if_block3(ctx)
  );
  thumb = new Thumb_default({
    props: {
      positionValue: (
        /*_currentTimePercentage*/
        ctx[6]
      ),
      active: (
        /*isPointerDown*/
        ctx[3]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      create_component(bar0.$$.fragment);
      t0 = space();
      create_component(bar1.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      create_component(thumb.$$.fragment);
      attr_dev(div0, "class", "bars svelte-wdgqi3");
      set_style(
        div0,
        "height",
        /*$cfg*/
        ctx[1].trackHeight
      );
      set_style(
        div0,
        "outline-color",
        /*$cfg*/
        ctx[1].focusColor
      );
      add_location(div0, file11, 141, 2, 3254);
      attr_dev(div1, "class", "playbar svelte-wdgqi3");
      attr_dev(div1, "tabindex", "0");
      set_style(div1, "margin", "0 " + /*marginX*/
      ctx[0]);
      add_location(div1, file11, 135, 0, 3115);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      mount_component(bar0, div0, null);
      append_dev(div0, t0);
      mount_component(bar1, div0, null);
      append_dev(div0, t1);
      if (if_block)
        if_block.m(div0, null);
      append_dev(div1, t2);
      mount_component(thumb, div1, null);
      ctx[18](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "pointermove",
            /*onPointerMove*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "pointerup",
            /*onPointerUp*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "pointerdown",
            /*onPointerDown*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const bar0_changes = {};
      if (dirty & /*$cfg*/
      2)
        bar0_changes.color = /*$cfg*/
        ctx2[1].barsBgColor;
      bar0.$set(bar0_changes);
      const bar1_changes = {};
      if (dirty & /*$cfg*/
      2)
        bar1_changes.color = /*$cfg*/
        ctx2[1].color;
      if (dirty & /*_currentTimePercentage*/
      64)
        bar1_changes.value = /*_currentTimePercentage*/
        ctx2[6];
      bar1.$set(bar1_changes);
      if (
        /*$cfg*/
        ctx2[1].chunkBars
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$cfg*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*$cfg*/
      2) {
        set_style(
          div0,
          "height",
          /*$cfg*/
          ctx2[1].trackHeight
        );
      }
      if (!current || dirty & /*$cfg*/
      2) {
        set_style(
          div0,
          "outline-color",
          /*$cfg*/
          ctx2[1].focusColor
        );
      }
      const thumb_changes = {};
      if (dirty & /*_currentTimePercentage*/
      64)
        thumb_changes.positionValue = /*_currentTimePercentage*/
        ctx2[6];
      if (dirty & /*isPointerDown*/
      8)
        thumb_changes.active = /*isPointerDown*/
        ctx2[3];
      thumb.$set(thumb_changes);
      if (!current || dirty & /*marginX*/
      1) {
        set_style(div1, "margin", "0 " + /*marginX*/
        ctx2[0]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(bar0.$$.fragment, local);
      transition_in(bar1.$$.fragment, local);
      transition_in(if_block);
      transition_in(thumb.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(bar0.$$.fragment, local);
      transition_out(bar1.$$.fragment, local);
      transition_out(if_block);
      transition_out(thumb.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_component(bar0);
      destroy_component(bar1);
      if (if_block)
        if_block.d();
      destroy_component(thumb);
      ctx[18](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let $cfg;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Playbar", slots, []);
  let { isBottomControlsVisible } = $$props;
  let { marginX = "10px" } = $$props;
  let { currentTime = 0 } = $$props;
  let { duration = 0 } = $$props;
  let { buffered = [] } = $$props;
  let { played = [] } = $$props;
  let { paused } = $$props;
  let { isScrubbing } = $$props;
  const dispatch = createEventDispatcher();
  const cfg = getContext("config");
  validate_store(cfg, "cfg");
  component_subscribe($$self, cfg, (value) => $$invalidate(1, $cfg = value));
  let playbarElement;
  let isPointerDown;
  let rect;
  let wasPaused;
  let _buffered;
  let _played;
  let _currentTimePercentage;
  function updateTime() {
    $$invalidate(6, _currentTimePercentage = currentTime / duration);
  }
  const updateTimeThrottled = throttle(
    (time) => {
      $$invalidate(6, _currentTimePercentage = time / duration);
    },
    250,
    true
  );
  const updateChunkBarsThrottled = throttle(
    (time) => {
      $$invalidate(4, _buffered = buffered.map((item) => {
        return {
          start: item.start / duration,
          end: item.end / duration
        };
      }));
      $$invalidate(5, _played = played.map((item) => {
        return {
          start: item.start / duration,
          end: item.end / duration
        };
      }));
    },
    250,
    true
  );
  function onPointerDown2(e) {
    e.preventDefault();
    $$invalidate(3, isPointerDown = true);
    wasPaused = paused;
    $$invalidate(13, paused = true);
    rect = playbarElement.getBoundingClientRect();
    pointerXToCurrentTime(e.clientX);
  }
  function onPointerMove(e) {
    if (!isPointerDown)
      return;
    $$invalidate(12, isScrubbing = true);
    pointerXToCurrentTime(e.clientX);
  }
  function onPointerUp(e) {
    if (!isPointerDown)
      return;
    $$invalidate(13, paused = wasPaused);
    $$invalidate(3, isPointerDown = false);
    $$invalidate(12, isScrubbing = false);
    dispatch("pointerup");
  }
  function pointerXToCurrentTime(clientX) {
    const value = Math.min(Math.max(clientX - rect.x, 0), rect.width) / rect.width;
    $$invalidate(11, currentTime = duration * value);
  }
  $$self.$$.on_mount.push(function() {
    if (isBottomControlsVisible === void 0 && !("isBottomControlsVisible" in $$props || $$self.$$.bound[$$self.$$.props["isBottomControlsVisible"]])) {
      console.warn("<Playbar> was created without expected prop 'isBottomControlsVisible'");
    }
    if (paused === void 0 && !("paused" in $$props || $$self.$$.bound[$$self.$$.props["paused"]])) {
      console.warn("<Playbar> was created without expected prop 'paused'");
    }
    if (isScrubbing === void 0 && !("isScrubbing" in $$props || $$self.$$.bound[$$self.$$.props["isScrubbing"]])) {
      console.warn("<Playbar> was created without expected prop 'isScrubbing'");
    }
  });
  const writable_props = [
    "isBottomControlsVisible",
    "marginX",
    "currentTime",
    "duration",
    "buffered",
    "played",
    "paused",
    "isScrubbing"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Playbar> was created with unknown prop '${key}'`);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      playbarElement = $$value;
      $$invalidate(2, playbarElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("isBottomControlsVisible" in $$props2)
      $$invalidate(14, isBottomControlsVisible = $$props2.isBottomControlsVisible);
    if ("marginX" in $$props2)
      $$invalidate(0, marginX = $$props2.marginX);
    if ("currentTime" in $$props2)
      $$invalidate(11, currentTime = $$props2.currentTime);
    if ("duration" in $$props2)
      $$invalidate(15, duration = $$props2.duration);
    if ("buffered" in $$props2)
      $$invalidate(16, buffered = $$props2.buffered);
    if ("played" in $$props2)
      $$invalidate(17, played = $$props2.played);
    if ("paused" in $$props2)
      $$invalidate(13, paused = $$props2.paused);
    if ("isScrubbing" in $$props2)
      $$invalidate(12, isScrubbing = $$props2.isScrubbing);
  };
  $$self.$capture_state = () => ({
    throttle,
    createEventDispatcher,
    getContext,
    Bar: Bar_default,
    Chunkbar: Chunkbar_default,
    Thumb: Thumb_default,
    isBottomControlsVisible,
    marginX,
    currentTime,
    duration,
    buffered,
    played,
    paused,
    isScrubbing,
    dispatch,
    cfg,
    playbarElement,
    isPointerDown,
    rect,
    wasPaused,
    _buffered,
    _played,
    _currentTimePercentage,
    updateTime,
    updateTimeThrottled,
    updateChunkBarsThrottled,
    onPointerDown: onPointerDown2,
    onPointerMove,
    onPointerUp,
    pointerXToCurrentTime,
    $cfg
  });
  $$self.$inject_state = ($$props2) => {
    if ("isBottomControlsVisible" in $$props2)
      $$invalidate(14, isBottomControlsVisible = $$props2.isBottomControlsVisible);
    if ("marginX" in $$props2)
      $$invalidate(0, marginX = $$props2.marginX);
    if ("currentTime" in $$props2)
      $$invalidate(11, currentTime = $$props2.currentTime);
    if ("duration" in $$props2)
      $$invalidate(15, duration = $$props2.duration);
    if ("buffered" in $$props2)
      $$invalidate(16, buffered = $$props2.buffered);
    if ("played" in $$props2)
      $$invalidate(17, played = $$props2.played);
    if ("paused" in $$props2)
      $$invalidate(13, paused = $$props2.paused);
    if ("isScrubbing" in $$props2)
      $$invalidate(12, isScrubbing = $$props2.isScrubbing);
    if ("playbarElement" in $$props2)
      $$invalidate(2, playbarElement = $$props2.playbarElement);
    if ("isPointerDown" in $$props2)
      $$invalidate(3, isPointerDown = $$props2.isPointerDown);
    if ("rect" in $$props2)
      rect = $$props2.rect;
    if ("wasPaused" in $$props2)
      wasPaused = $$props2.wasPaused;
    if ("_buffered" in $$props2)
      $$invalidate(4, _buffered = $$props2._buffered);
    if ("_played" in $$props2)
      $$invalidate(5, _played = $$props2._played);
    if ("_currentTimePercentage" in $$props2)
      $$invalidate(6, _currentTimePercentage = $$props2._currentTimePercentage);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*isBottomControlsVisible, $cfg, currentTime*/
    18434) {
      $: {
        if (isBottomControlsVisible && $cfg.chunkBars) {
          updateChunkBarsThrottled(currentTime);
        }
      }
    }
    if ($$self.$$.dirty & /*isBottomControlsVisible, isScrubbing, currentTime*/
    22528) {
      $: {
        if (isBottomControlsVisible) {
          if (isScrubbing)
            updateTime(currentTime);
          else
            updateTimeThrottled(currentTime);
        }
      }
    }
  };
  return [
    marginX,
    $cfg,
    playbarElement,
    isPointerDown,
    _buffered,
    _played,
    _currentTimePercentage,
    cfg,
    onPointerDown2,
    onPointerMove,
    onPointerUp,
    currentTime,
    isScrubbing,
    paused,
    isBottomControlsVisible,
    duration,
    buffered,
    played,
    div1_binding
  ];
}
var Playbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance11,
      create_fragment11,
      safe_not_equal,
      {
        isBottomControlsVisible: 14,
        marginX: 0,
        currentTime: 11,
        duration: 15,
        buffered: 16,
        played: 17,
        paused: 13,
        isScrubbing: 12
      },
      add_css11
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Playbar",
      options,
      id: create_fragment11.name
    });
  }
  get isBottomControlsVisible() {
    throw new Error("<Playbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isBottomControlsVisible(value) {
    throw new Error("<Playbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get marginX() {
    throw new Error("<Playbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set marginX(value) {
    throw new Error("<Playbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get currentTime() {
    throw new Error("<Playbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set currentTime(value) {
    throw new Error("<Playbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Playbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Playbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buffered() {
    throw new Error("<Playbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buffered(value) {
    throw new Error("<Playbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get played() {
    throw new Error("<Playbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set played(value) {
    throw new Error("<Playbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get paused() {
    throw new Error("<Playbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set paused(value) {
    throw new Error("<Playbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isScrubbing() {
    throw new Error("<Playbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isScrubbing(value) {
    throw new Error("<Playbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Playbar_default = Playbar;

// node_modules/svelte-video-player/src/Button.svelte
var file12 = "node_modules/svelte-video-player/src/Button.svelte";
function add_css12(target) {
  append_styles(target, "svelte-ievgfv", ".button.svelte-ievgfv{box-sizing:border-box;position:relative;height:100%;border-style:none;border-radius:10px;border-width:2px;outline:none;cursor:pointer}@media(hover: hover) and (pointer: fine){.button.svelte-ievgfv:focus{border-style:solid}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnV0dG9uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFrQ0UscUJBQVEsQ0FDTixVQUFVLENBQUUsVUFBVSxDQUN0QixRQUFRLENBQUUsUUFBUSxDQUNsQixNQUFNLENBQUUsSUFBSSxDQUNaLFlBQVksQ0FBRSxJQUFJLENBQ2xCLGFBQWEsQ0FBRSxJQUFJLENBQ25CLFlBQVksQ0FBRSxHQUFHLENBQ2pCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsTUFBTSxDQUFFLE9BQ1YsQ0FFQSxNQUFPLFFBQVEsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQVUsSUFBSSxDQUFFLENBQ3hDLHFCQUFPLE1BQU8sQ0FDWixZQUFZLENBQUUsS0FDaEIsQ0FDRiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJCdXR0b24uc3ZlbHRlIl19 */");
}
function create_fragment12(ctx) {
  let div;
  let div_resize_listener;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "button svelte-ievgfv");
      set_style(
        div,
        "width",
        /*offsetHeight*/
        ctx[1] + "px"
      );
      set_style(
        div,
        "min-width",
        /*offsetHeight*/
        ctx[1] + "px"
      );
      set_style(
        div,
        "background-color",
        /*$cfg*/
        ctx[2].color
      );
      set_style(
        div,
        "border-color",
        /*$cfg*/
        ctx[2].focusColor
      );
      set_style(
        div,
        "border-radius",
        /*round*/
        ctx[0] ? "9999px" : "10px"
      );
      attr_dev(div, "tabindex", "0");
      add_render_callback(() => (
        /*div_elementresize_handler*/
        ctx[8].call(div)
      ));
      add_location(div, file12, 52, 0, 1010);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      div_resize_listener = add_iframe_resize_listener(
        div,
        /*div_elementresize_handler*/
        ctx[8].bind(div)
      );
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div, "pointerdown", onPointerDown, false, false, false, false),
          listen_dev(
            div,
            "pointerup",
            /*onPointerUp*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*onKeydown*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*offsetHeight*/
      2) {
        set_style(
          div,
          "width",
          /*offsetHeight*/
          ctx2[1] + "px"
        );
      }
      if (!current || dirty & /*offsetHeight*/
      2) {
        set_style(
          div,
          "min-width",
          /*offsetHeight*/
          ctx2[1] + "px"
        );
      }
      if (!current || dirty & /*$cfg*/
      4) {
        set_style(
          div,
          "background-color",
          /*$cfg*/
          ctx2[2].color
        );
      }
      if (!current || dirty & /*$cfg*/
      4) {
        set_style(
          div,
          "border-color",
          /*$cfg*/
          ctx2[2].focusColor
        );
      }
      if (!current || dirty & /*round*/
      1) {
        set_style(
          div,
          "border-radius",
          /*round*/
          ctx2[0] ? "9999px" : "10px"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      div_resize_listener();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function onPointerDown(e) {
  e.preventDefault();
}
function instance12($$self, $$props, $$invalidate) {
  let $cfg;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button", slots, ["default"]);
  let { round = false } = $$props;
  const dispatch = createEventDispatcher();
  const cfg = getContext("config");
  validate_store(cfg, "cfg");
  component_subscribe($$self, cfg, (value) => $$invalidate(2, $cfg = value));
  let offsetHeight;
  function onPointerUp(e) {
    dispatch("pointerup");
  }
  function onKeydown(e) {
    switch (e.code) {
      case "Enter":
      case "NumpadEnter":
      case "Space":
        e.preventDefault();
        e.stopPropagation();
        dispatch(
          "pointerup"
        );
        break;
    }
  }
  const writable_props = ["round"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Button> was created with unknown prop '${key}'`);
  });
  function div_elementresize_handler() {
    offsetHeight = this.offsetHeight;
    $$invalidate(1, offsetHeight);
  }
  $$self.$$set = ($$props2) => {
    if ("round" in $$props2)
      $$invalidate(0, round = $$props2.round);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    getContext,
    round,
    dispatch,
    cfg,
    offsetHeight,
    onPointerDown,
    onPointerUp,
    onKeydown,
    $cfg
  });
  $$self.$inject_state = ($$props2) => {
    if ("round" in $$props2)
      $$invalidate(0, round = $$props2.round);
    if ("offsetHeight" in $$props2)
      $$invalidate(1, offsetHeight = $$props2.offsetHeight);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    round,
    offsetHeight,
    $cfg,
    cfg,
    onPointerUp,
    onKeydown,
    $$scope,
    slots,
    div_elementresize_handler
  ];
}
var Button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { round: 0 }, add_css12);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment12.name
    });
  }
  get round() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set round(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Button_default = Button;

// node_modules/svelte-video-player/src/PlayPauseButton.svelte
function create_default_slot(ctx) {
  let playpauseicon;
  let current;
  playpauseicon = new PlayPauseIcon_default({
    props: { paused: (
      /*paused*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(playpauseicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(playpauseicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const playpauseicon_changes = {};
      if (dirty & /*paused*/
      1)
        playpauseicon_changes.paused = /*paused*/
        ctx2[0];
      playpauseicon.$set(playpauseicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(playpauseicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(playpauseicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(playpauseicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(8:0) <Button on:pointerup>",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[1]
  );
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const button_changes = {};
      if (dirty & /*$$scope, paused*/
      5) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PlayPauseButton", slots, []);
  let { paused } = $$props;
  $$self.$$.on_mount.push(function() {
    if (paused === void 0 && !("paused" in $$props || $$self.$$.bound[$$self.$$.props["paused"]])) {
      console.warn("<PlayPauseButton> was created without expected prop 'paused'");
    }
  });
  const writable_props = ["paused"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PlayPauseButton> was created with unknown prop '${key}'`);
  });
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("paused" in $$props2)
      $$invalidate(0, paused = $$props2.paused);
  };
  $$self.$capture_state = () => ({ Button: Button_default, PlayPauseIcon: PlayPauseIcon_default, paused });
  $$self.$inject_state = ($$props2) => {
    if ("paused" in $$props2)
      $$invalidate(0, paused = $$props2.paused);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [paused, pointerup_handler];
}
var PlayPauseButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { paused: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PlayPauseButton",
      options,
      id: create_fragment13.name
    });
  }
  get paused() {
    throw new Error("<PlayPauseButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set paused(value) {
    throw new Error("<PlayPauseButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PlayPauseButton_default = PlayPauseButton;

// node_modules/svelte-video-player/src/VolumeIcon.svelte
var file13 = "node_modules/svelte-video-player/src/VolumeIcon.svelte";
function add_css13(target) {
  append_styles(target, "svelte-rnfp7y", ".volume-icon.svelte-rnfp7y{position:absolute}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVm9sdW1lSWNvbi5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBV0UsMEJBQWEsQ0FDWCxRQUFRLENBQUUsUUFDWiIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJWb2x1bWVJY29uLnN2ZWx0ZSJdfQ== */");
}
function create_fragment14(ctx) {
  let div;
  let svg;
  let g2;
  let path0;
  let path0_fill_value;
  let g0;
  let path1;
  let path2;
  let g0_visibility_value;
  let g1;
  let path3;
  let path4;
  let g1_visibility_value;
  let g2_stroke_value;
  const block = {
    c: function create() {
      div = element("div");
      svg = svg_element("svg");
      g2 = svg_element("g");
      path0 = svg_element("path");
      g0 = svg_element("g");
      path1 = svg_element("path");
      path2 = svg_element("path");
      g1 = svg_element("g");
      path3 = svg_element("path");
      path4 = svg_element("path");
      attr_dev(path0, "fill", path0_fill_value = /*filled*/
      ctx[1] ? (
        /*$cfg*/
        ctx[3].iconColor
      ) : "none");
      attr_dev(path0, "d", "M33.913 38.955l14.58-11.046v44.918l-14.58-11.045H22.154V38.955h11.759z");
      add_location(path0, file13, 19, 6, 447);
      attr_dev(path1, "d", "M68.27 31.776c10.039 10.058 10.039 26.39 0 36.448");
      add_location(path1, file13, 23, 8, 652);
      attr_dev(path2, "d", "M61.062 38.986c6.067 6.079 6.067 15.949 0 22.028");
      add_location(path2, file13, 24, 8, 724);
      attr_dev(g0, "visibility", g0_visibility_value = !/*muted*/
      ctx[2] ? "visible" : "hidden");
      add_location(g0, file13, 22, 6, 596);
      attr_dev(path3, "d", "M59.644 41.173l17.621 17.658");
      add_location(path3, file13, 27, 8, 860);
      attr_dev(path4, "d", "M77.265 41.173L59.644 58.831");
      add_location(path4, file13, 28, 8, 911);
      attr_dev(g1, "visibility", g1_visibility_value = /*muted*/
      ctx[2] ? "visible" : "hidden");
      add_location(g1, file13, 26, 6, 805);
      attr_dev(g2, "fill", "none");
      attr_dev(g2, "stroke", g2_stroke_value = /*$cfg*/
      ctx[3].iconColor);
      attr_dev(g2, "stroke-width", "5");
      add_location(g2, file13, 18, 4, 383);
      attr_dev(svg, "viewBox", "0 0 100 100");
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      add_location(svg, file13, 17, 2, 303);
      attr_dev(div, "class", "volume-icon svelte-rnfp7y");
      set_style(
        div,
        "width",
        /*size*/
        ctx[0]
      );
      add_location(div, file13, 16, 0, 252);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, svg);
      append_dev(svg, g2);
      append_dev(g2, path0);
      append_dev(g2, g0);
      append_dev(g0, path1);
      append_dev(g0, path2);
      append_dev(g2, g1);
      append_dev(g1, path3);
      append_dev(g1, path4);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*filled, $cfg*/
      10 && path0_fill_value !== (path0_fill_value = /*filled*/
      ctx2[1] ? (
        /*$cfg*/
        ctx2[3].iconColor
      ) : "none")) {
        attr_dev(path0, "fill", path0_fill_value);
      }
      if (dirty & /*muted*/
      4 && g0_visibility_value !== (g0_visibility_value = !/*muted*/
      ctx2[2] ? "visible" : "hidden")) {
        attr_dev(g0, "visibility", g0_visibility_value);
      }
      if (dirty & /*muted*/
      4 && g1_visibility_value !== (g1_visibility_value = /*muted*/
      ctx2[2] ? "visible" : "hidden")) {
        attr_dev(g1, "visibility", g1_visibility_value);
      }
      if (dirty & /*$cfg*/
      8 && g2_stroke_value !== (g2_stroke_value = /*$cfg*/
      ctx2[3].iconColor)) {
        attr_dev(g2, "stroke", g2_stroke_value);
      }
      if (dirty & /*size*/
      1) {
        set_style(
          div,
          "width",
          /*size*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let $cfg;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VolumeIcon", slots, []);
  let { size = "100%" } = $$props;
  let { filled = true } = $$props;
  let { muted } = $$props;
  const cfg = getContext("config");
  validate_store(cfg, "cfg");
  component_subscribe($$self, cfg, (value) => $$invalidate(3, $cfg = value));
  $$self.$$.on_mount.push(function() {
    if (muted === void 0 && !("muted" in $$props || $$self.$$.bound[$$self.$$.props["muted"]])) {
      console.warn("<VolumeIcon> was created without expected prop 'muted'");
    }
  });
  const writable_props = ["size", "filled", "muted"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VolumeIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("filled" in $$props2)
      $$invalidate(1, filled = $$props2.filled);
    if ("muted" in $$props2)
      $$invalidate(2, muted = $$props2.muted);
  };
  $$self.$capture_state = () => ({
    getContext,
    size,
    filled,
    muted,
    cfg,
    $cfg
  });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("filled" in $$props2)
      $$invalidate(1, filled = $$props2.filled);
    if ("muted" in $$props2)
      $$invalidate(2, muted = $$props2.muted);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, filled, muted, $cfg, cfg];
}
var VolumeIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { size: 0, filled: 1, muted: 2 }, add_css13);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VolumeIcon",
      options,
      id: create_fragment14.name
    });
  }
  get size() {
    throw new Error("<VolumeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<VolumeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filled() {
    throw new Error("<VolumeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filled(value) {
    throw new Error("<VolumeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get muted() {
    throw new Error("<VolumeIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set muted(value) {
    throw new Error("<VolumeIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VolumeIcon_default = VolumeIcon;

// node_modules/svelte-video-player/src/VolumeButton.svelte
function create_default_slot2(ctx) {
  let volumeicon;
  let current;
  volumeicon = new VolumeIcon_default({
    props: { muted: (
      /*muted*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(volumeicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(volumeicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const volumeicon_changes = {};
      if (dirty & /*muted*/
      1)
        volumeicon_changes.muted = /*muted*/
        ctx2[0];
      volumeicon.$set(volumeicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(volumeicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(volumeicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(volumeicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(8:0) <Button on:pointerup>",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[1]
  );
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const button_changes = {};
      if (dirty & /*$$scope, muted*/
      5) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VolumeButton", slots, []);
  let { muted } = $$props;
  $$self.$$.on_mount.push(function() {
    if (muted === void 0 && !("muted" in $$props || $$self.$$.bound[$$self.$$.props["muted"]])) {
      console.warn("<VolumeButton> was created without expected prop 'muted'");
    }
  });
  const writable_props = ["muted"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VolumeButton> was created with unknown prop '${key}'`);
  });
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("muted" in $$props2)
      $$invalidate(0, muted = $$props2.muted);
  };
  $$self.$capture_state = () => ({ Button: Button_default, VolumeIcon: VolumeIcon_default, muted });
  $$self.$inject_state = ($$props2) => {
    if ("muted" in $$props2)
      $$invalidate(0, muted = $$props2.muted);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [muted, pointerup_handler];
}
var VolumeButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { muted: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VolumeButton",
      options,
      id: create_fragment15.name
    });
  }
  get muted() {
    throw new Error("<VolumeButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set muted(value) {
    throw new Error("<VolumeButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VolumeButton_default = VolumeButton;

// node_modules/svelte-video-player/src/Slider.svelte
var file14 = "node_modules/svelte-video-player/src/Slider.svelte";
function add_css14(target) {
  append_styles(target, "svelte-1qqqte2", ".slider.svelte-1qqqte2.svelte-1qqqte2{position:relative;flex-grow:1;min-width:25px;height:100%;outline:none}.slider.svelte-1qqqte2:focus .bars.svelte-1qqqte2{outline-style:dotted}.bars.svelte-1qqqte2.svelte-1qqqte2{position:relative;width:100%;top:50%;transform:translateY(-50%);outline-offset:3px;outline-width:2px;outline-style:none;border-radius:9999px;overflow:hidden}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2xpZGVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUEwREUscUNBQVEsQ0FDTixRQUFRLENBQUUsUUFBUSxDQUNsQixTQUFTLENBQUUsQ0FBQyxDQUNaLFNBQVMsQ0FBRSxJQUFJLENBQ2YsTUFBTSxDQUFFLElBQUksQ0FDWixPQUFPLENBQUUsSUFDWCxDQUVBLHNCQUFPLE1BQU0sQ0FBQyxvQkFBTSxDQUNsQixhQUFhLENBQUUsTUFDakIsQ0FFQSxtQ0FBTSxDQUNKLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEtBQUssQ0FBRSxJQUFJLENBQ1gsR0FBRyxDQUFFLEdBQUcsQ0FDUixTQUFTLENBQUUsV0FBVyxJQUFJLENBQUMsQ0FDM0IsY0FBYyxDQUFFLEdBQUcsQ0FDbkIsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsYUFBYSxDQUFFLElBQUksQ0FDbkIsYUFBYSxDQUFFLE1BQU0sQ0FDckIsUUFBUSxDQUFFLE1BQ1oiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiU2xpZGVyLnN2ZWx0ZSJdfQ== */");
}
function create_fragment16(ctx) {
  let div1;
  let div0;
  let bar0;
  let t0;
  let bar1;
  let t1;
  let thumb;
  let current;
  let mounted;
  let dispose;
  bar0 = new Bar_default({
    props: {
      color: (
        /*$cfg*/
        ctx[5].barsBgColor
      ),
      opacity: 1,
      value: 1
    },
    $$inline: true
  });
  bar1 = new Bar_default({
    props: {
      color: (
        /*$cfg*/
        ctx[5].color
      ),
      opacity: 1,
      value: (
        /*value*/
        ctx[0]
      )
    },
    $$inline: true
  });
  thumb = new Thumb_default({
    props: {
      positionValue: (
        /*value*/
        ctx[0]
      ),
      active: (
        /*isPointerDown*/
        ctx[4]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      create_component(bar0.$$.fragment);
      t0 = space();
      create_component(bar1.$$.fragment);
      t1 = space();
      create_component(thumb.$$.fragment);
      attr_dev(div0, "class", "bars svelte-1qqqte2");
      set_style(
        div0,
        "height",
        /*$cfg*/
        ctx[5].trackHeight
      );
      set_style(
        div0,
        "outline-color",
        /*$cfg*/
        ctx[5].focusColor
      );
      add_location(div0, file14, 92, 2, 1989);
      attr_dev(div1, "class", "slider svelte-1qqqte2");
      set_style(
        div1,
        "max-width",
        /*width*/
        ctx[1]
      );
      set_style(div1, "margin", "0 " + /*marginX*/
      ctx[2]);
      attr_dev(div1, "tabindex", "0");
      add_location(div1, file14, 85, 0, 1807);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      mount_component(bar0, div0, null);
      append_dev(div0, t0);
      mount_component(bar1, div0, null);
      append_dev(div1, t1);
      mount_component(thumb, div1, null);
      ctx[11](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "pointermove",
            /*onPointerMove*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "pointerup",
            /*onPointerUp*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "pointerdown",
            /*onPointerDown*/
            ctx[7],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keydown",
            /*onKeydown*/
            ctx[10],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const bar0_changes = {};
      if (dirty & /*$cfg*/
      32)
        bar0_changes.color = /*$cfg*/
        ctx2[5].barsBgColor;
      bar0.$set(bar0_changes);
      const bar1_changes = {};
      if (dirty & /*$cfg*/
      32)
        bar1_changes.color = /*$cfg*/
        ctx2[5].color;
      if (dirty & /*value*/
      1)
        bar1_changes.value = /*value*/
        ctx2[0];
      bar1.$set(bar1_changes);
      if (!current || dirty & /*$cfg*/
      32) {
        set_style(
          div0,
          "height",
          /*$cfg*/
          ctx2[5].trackHeight
        );
      }
      if (!current || dirty & /*$cfg*/
      32) {
        set_style(
          div0,
          "outline-color",
          /*$cfg*/
          ctx2[5].focusColor
        );
      }
      const thumb_changes = {};
      if (dirty & /*value*/
      1)
        thumb_changes.positionValue = /*value*/
        ctx2[0];
      if (dirty & /*isPointerDown*/
      16)
        thumb_changes.active = /*isPointerDown*/
        ctx2[4];
      thumb.$set(thumb_changes);
      if (!current || dirty & /*width*/
      2) {
        set_style(
          div1,
          "max-width",
          /*width*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*marginX*/
      4) {
        set_style(div1, "margin", "0 " + /*marginX*/
        ctx2[2]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(bar0.$$.fragment, local);
      transition_in(bar1.$$.fragment, local);
      transition_in(thumb.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(bar0.$$.fragment, local);
      transition_out(bar1.$$.fragment, local);
      transition_out(thumb.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_component(bar0);
      destroy_component(bar1);
      destroy_component(thumb);
      ctx[11](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let $cfg;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Slider", slots, []);
  let { width = "150px" } = $$props;
  let { marginX = "10px" } = $$props;
  let { value = 0.5 } = $$props;
  let sliderElement;
  let isPointerDown;
  let rect;
  const cfg = getContext("config");
  validate_store(cfg, "cfg");
  component_subscribe($$self, cfg, (value2) => $$invalidate(5, $cfg = value2));
  function onPointerDown2(e) {
    e.preventDefault();
    $$invalidate(4, isPointerDown = true);
    rect = sliderElement.getBoundingClientRect();
    pointerXToValue(e.clientX);
  }
  function onPointerMove(e) {
    if (!isPointerDown)
      return;
    pointerXToValue(e.clientX);
  }
  function onPointerUp(e) {
    if (!isPointerDown)
      return;
    $$invalidate(4, isPointerDown = false);
  }
  function onKeydown(e) {
    switch (e.code) {
      case "ArrowLeft":
      case "ArrowDown":
        keydownAddToValue(e, -0.1);
        break;
      case "ArrowRight":
      case "ArrowUp":
        keydownAddToValue(e, 0.1);
        break;
    }
  }
  function keydownAddToValue(e, v) {
    e.preventDefault();
    e.stopPropagation();
    $$invalidate(0, value = Math.min(Math.max(value + v, 0), 1));
  }
  function pointerXToValue(clientX) {
    $$invalidate(0, value = Math.min(Math.max(clientX - rect.x, 0), rect.width) / rect.width);
  }
  const writable_props = ["width", "marginX", "value"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Slider> was created with unknown prop '${key}'`);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      sliderElement = $$value;
      $$invalidate(3, sliderElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("marginX" in $$props2)
      $$invalidate(2, marginX = $$props2.marginX);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  $$self.$capture_state = () => ({
    getContext,
    Thumb: Thumb_default,
    Bar: Bar_default,
    width,
    marginX,
    value,
    sliderElement,
    isPointerDown,
    rect,
    cfg,
    onPointerDown: onPointerDown2,
    onPointerMove,
    onPointerUp,
    onKeydown,
    keydownAddToValue,
    pointerXToValue,
    $cfg
  });
  $$self.$inject_state = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("marginX" in $$props2)
      $$invalidate(2, marginX = $$props2.marginX);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("sliderElement" in $$props2)
      $$invalidate(3, sliderElement = $$props2.sliderElement);
    if ("isPointerDown" in $$props2)
      $$invalidate(4, isPointerDown = $$props2.isPointerDown);
    if ("rect" in $$props2)
      rect = $$props2.rect;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    value,
    width,
    marginX,
    sliderElement,
    isPointerDown,
    $cfg,
    cfg,
    onPointerDown2,
    onPointerMove,
    onPointerUp,
    onKeydown,
    div1_binding
  ];
}
var Slider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { width: 1, marginX: 2, value: 0 }, add_css14);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Slider",
      options,
      id: create_fragment16.name
    });
  }
  get width() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get marginX() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set marginX(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Slider_default = Slider;

// node_modules/svelte-video-player/src/VolumeControl.svelte
function create_fragment17(ctx) {
  let slider;
  let updating_value;
  let current;
  function slider_value_binding(value) {
    ctx[2](value);
  }
  let slider_props = { width: (
    /*width*/
    ctx[1]
  ) };
  if (
    /*volume*/
    ctx[0] !== void 0
  ) {
    slider_props.value = /*volume*/
    ctx[0];
  }
  slider = new Slider_default({ props: slider_props, $$inline: true });
  binding_callbacks.push(() => bind(slider, "value", slider_value_binding));
  const block = {
    c: function create() {
      create_component(slider.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(slider, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const slider_changes = {};
      if (dirty & /*width*/
      2)
        slider_changes.width = /*width*/
        ctx2[1];
      if (!updating_value && dirty & /*volume*/
      1) {
        updating_value = true;
        slider_changes.value = /*volume*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      slider.$set(slider_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(slider.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(slider.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(slider, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VolumeControl", slots, []);
  let { width = "100px" } = $$props;
  let { volume = 1 } = $$props;
  const writable_props = ["width", "volume"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VolumeControl> was created with unknown prop '${key}'`);
  });
  function slider_value_binding(value) {
    volume = value;
    $$invalidate(0, volume);
  }
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("volume" in $$props2)
      $$invalidate(0, volume = $$props2.volume);
  };
  $$self.$capture_state = () => ({ Slider: Slider_default, width, volume });
  $$self.$inject_state = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("volume" in $$props2)
      $$invalidate(0, volume = $$props2.volume);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [volume, width, slider_value_binding];
}
var VolumeControl = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { width: 1, volume: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VolumeControl",
      options,
      id: create_fragment17.name
    });
  }
  get width() {
    throw new Error("<VolumeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<VolumeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get volume() {
    throw new Error("<VolumeControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set volume(value) {
    throw new Error("<VolumeControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VolumeControl_default = VolumeControl;

// node_modules/svelte-video-player/src/FullscreenIcon.svelte
var file15 = "node_modules/svelte-video-player/src/FullscreenIcon.svelte";
function add_css15(target) {
  append_styles(target, "svelte-15g0vgp", ".fullscreen-icon.svelte-15g0vgp{position:absolute}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRnVsbHNjcmVlbkljb24uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQVVFLCtCQUFpQixDQUNmLFFBQVEsQ0FBRSxRQUNaIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkZ1bGxzY3JlZW5JY29uLnN2ZWx0ZSJdfQ== */");
}
function create_fragment18(ctx) {
  let div;
  let svg;
  let g2;
  let g0;
  let path0;
  let path1;
  let path2;
  let path3;
  let g0_visibility_value;
  let g1;
  let path4;
  let path5;
  let path6;
  let path7;
  let g1_visibility_value;
  let g2_stroke_value;
  const block = {
    c: function create() {
      div = element("div");
      svg = svg_element("svg");
      g2 = svg_element("g");
      g0 = svg_element("g");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      path3 = svg_element("path");
      g1 = svg_element("g");
      path4 = svg_element("path");
      path5 = svg_element("path");
      path6 = svg_element("path");
      path7 = svg_element("path");
      attr_dev(path0, "d", "M71 60.5V71H60");
      add_location(path0, file15, 19, 8, 496);
      attr_dev(path1, "d", "M40 71H29V60.5");
      add_location(path1, file15, 20, 8, 533);
      attr_dev(path2, "d", "M29 40.5V29h11");
      add_location(path2, file15, 21, 8, 570);
      attr_dev(path3, "d", "M60 29h11v11.5");
      add_location(path3, file15, 22, 8, 607);
      attr_dev(g0, "visibility", g0_visibility_value = !/*isFullscreen*/
      ctx[1] ? "visible" : "hidden");
      add_location(g0, file15, 18, 6, 433);
      attr_dev(path4, "d", "M60 71V60.5h11");
      add_location(path4, file15, 25, 8, 716);
      attr_dev(path5, "d", "M29 60.5h11V71");
      add_location(path5, file15, 26, 8, 753);
      attr_dev(path6, "d", "M40 29v11.5H29");
      add_location(path6, file15, 27, 8, 790);
      attr_dev(path7, "d", "M71 40.5H60V29");
      add_location(path7, file15, 28, 8, 827);
      attr_dev(g1, "visibility", g1_visibility_value = /*isFullscreen*/
      ctx[1] ? "visible" : "hidden");
      add_location(g1, file15, 24, 6, 654);
      attr_dev(g2, "fill", "none");
      attr_dev(g2, "stroke", g2_stroke_value = /*$cfg*/
      ctx[2].iconColor);
      attr_dev(g2, "stroke-width", "5");
      add_location(g2, file15, 17, 4, 369);
      attr_dev(svg, "viewBox", "0 0 100 100");
      attr_dev(svg, "stroke-linecap", "round");
      attr_dev(svg, "stroke-linejoin", "round");
      add_location(svg, file15, 16, 2, 289);
      attr_dev(div, "class", "fullscreen-icon svelte-15g0vgp");
      set_style(
        div,
        "width",
        /*size*/
        ctx[0]
      );
      add_location(div, file15, 15, 0, 234);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, svg);
      append_dev(svg, g2);
      append_dev(g2, g0);
      append_dev(g0, path0);
      append_dev(g0, path1);
      append_dev(g0, path2);
      append_dev(g0, path3);
      append_dev(g2, g1);
      append_dev(g1, path4);
      append_dev(g1, path5);
      append_dev(g1, path6);
      append_dev(g1, path7);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*isFullscreen*/
      2 && g0_visibility_value !== (g0_visibility_value = !/*isFullscreen*/
      ctx2[1] ? "visible" : "hidden")) {
        attr_dev(g0, "visibility", g0_visibility_value);
      }
      if (dirty & /*isFullscreen*/
      2 && g1_visibility_value !== (g1_visibility_value = /*isFullscreen*/
      ctx2[1] ? "visible" : "hidden")) {
        attr_dev(g1, "visibility", g1_visibility_value);
      }
      if (dirty & /*$cfg*/
      4 && g2_stroke_value !== (g2_stroke_value = /*$cfg*/
      ctx2[2].iconColor)) {
        attr_dev(g2, "stroke", g2_stroke_value);
      }
      if (dirty & /*size*/
      1) {
        set_style(
          div,
          "width",
          /*size*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let $cfg;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FullscreenIcon", slots, []);
  let { size = "100%" } = $$props;
  let { isFullscreen: isFullscreen2 } = $$props;
  const cfg = getContext("config");
  validate_store(cfg, "cfg");
  component_subscribe($$self, cfg, (value) => $$invalidate(2, $cfg = value));
  $$self.$$.on_mount.push(function() {
    if (isFullscreen2 === void 0 && !("isFullscreen" in $$props || $$self.$$.bound[$$self.$$.props["isFullscreen"]])) {
      console.warn("<FullscreenIcon> was created without expected prop 'isFullscreen'");
    }
  });
  const writable_props = ["size", "isFullscreen"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FullscreenIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("isFullscreen" in $$props2)
      $$invalidate(1, isFullscreen2 = $$props2.isFullscreen);
  };
  $$self.$capture_state = () => ({
    getContext,
    size,
    isFullscreen: isFullscreen2,
    cfg,
    $cfg
  });
  $$self.$inject_state = ($$props2) => {
    if ("size" in $$props2)
      $$invalidate(0, size = $$props2.size);
    if ("isFullscreen" in $$props2)
      $$invalidate(1, isFullscreen2 = $$props2.isFullscreen);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [size, isFullscreen2, $cfg, cfg];
}
var FullscreenIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { size: 0, isFullscreen: 1 }, add_css15);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FullscreenIcon",
      options,
      id: create_fragment18.name
    });
  }
  get size() {
    throw new Error("<FullscreenIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<FullscreenIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isFullscreen() {
    throw new Error("<FullscreenIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isFullscreen(value) {
    throw new Error("<FullscreenIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FullscreenIcon_default = FullscreenIcon;

// node_modules/svelte-video-player/src/FullscreenButton.svelte
function create_default_slot3(ctx) {
  let fullscreenicon;
  let current;
  fullscreenicon = new FullscreenIcon_default({
    props: { isFullscreen: (
      /*isFullscreen*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(fullscreenicon.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(fullscreenicon, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const fullscreenicon_changes = {};
      if (dirty & /*isFullscreen*/
      1)
        fullscreenicon_changes.isFullscreen = /*isFullscreen*/
        ctx2[0];
      fullscreenicon.$set(fullscreenicon_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(fullscreenicon.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(fullscreenicon.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(fullscreenicon, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(8:0) <Button on:pointerup>",
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on(
    "pointerup",
    /*pointerup_handler*/
    ctx[1]
  );
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const button_changes = {};
      if (dirty & /*$$scope, isFullscreen*/
      5) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FullscreenButton", slots, []);
  let { isFullscreen: isFullscreen2 } = $$props;
  $$self.$$.on_mount.push(function() {
    if (isFullscreen2 === void 0 && !("isFullscreen" in $$props || $$self.$$.bound[$$self.$$.props["isFullscreen"]])) {
      console.warn("<FullscreenButton> was created without expected prop 'isFullscreen'");
    }
  });
  const writable_props = ["isFullscreen"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FullscreenButton> was created with unknown prop '${key}'`);
  });
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("isFullscreen" in $$props2)
      $$invalidate(0, isFullscreen2 = $$props2.isFullscreen);
  };
  $$self.$capture_state = () => ({ Button: Button_default, FullscreenIcon: FullscreenIcon_default, isFullscreen: isFullscreen2 });
  $$self.$inject_state = ($$props2) => {
    if ("isFullscreen" in $$props2)
      $$invalidate(0, isFullscreen2 = $$props2.isFullscreen);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [isFullscreen2, pointerup_handler];
}
var FullscreenButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { isFullscreen: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FullscreenButton",
      options,
      id: create_fragment19.name
    });
  }
  get isFullscreen() {
    throw new Error("<FullscreenButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isFullscreen(value) {
    throw new Error("<FullscreenButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FullscreenButton_default = FullscreenButton;

// node_modules/svelte-video-player/src/FullscreenManager.svelte
var screenfull = __toESM(require_screenfull());
function create_fragment20(ctx) {
  const block = {
    c: noop,
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FullscreenManager", slots, []);
  let { element: element2 } = $$props;
  let { isFullscreen: isFullscreen2 } = $$props;
  let { isFullscreenEnabled } = $$props;
  isFullscreenEnabled = screenfull.isEnabled;
  if (isFullscreenEnabled)
    screenfull.on("change", onChange);
  function onChange(e) {
    if (element2 == e.target)
      $$invalidate(0, isFullscreen2 = screenfull.isFullscreen);
  }
  onDestroy(() => {
    screenfull.off("change", onChange);
  });
  $$self.$$.on_mount.push(function() {
    if (element2 === void 0 && !("element" in $$props || $$self.$$.bound[$$self.$$.props["element"]])) {
      console.warn("<FullscreenManager> was created without expected prop 'element'");
    }
    if (isFullscreen2 === void 0 && !("isFullscreen" in $$props || $$self.$$.bound[$$self.$$.props["isFullscreen"]])) {
      console.warn("<FullscreenManager> was created without expected prop 'isFullscreen'");
    }
    if (isFullscreenEnabled === void 0 && !("isFullscreenEnabled" in $$props || $$self.$$.bound[$$self.$$.props["isFullscreenEnabled"]])) {
      console.warn("<FullscreenManager> was created without expected prop 'isFullscreenEnabled'");
    }
  });
  const writable_props = ["element", "isFullscreen", "isFullscreenEnabled"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<FullscreenManager> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(2, element2 = $$props2.element);
    if ("isFullscreen" in $$props2)
      $$invalidate(0, isFullscreen2 = $$props2.isFullscreen);
    if ("isFullscreenEnabled" in $$props2)
      $$invalidate(1, isFullscreenEnabled = $$props2.isFullscreenEnabled);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    screenfull,
    element: element2,
    isFullscreen: isFullscreen2,
    isFullscreenEnabled,
    onChange
  });
  $$self.$inject_state = ($$props2) => {
    if ("element" in $$props2)
      $$invalidate(2, element2 = $$props2.element);
    if ("isFullscreen" in $$props2)
      $$invalidate(0, isFullscreen2 = $$props2.isFullscreen);
    if ("isFullscreenEnabled" in $$props2)
      $$invalidate(1, isFullscreenEnabled = $$props2.isFullscreenEnabled);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*isFullscreenEnabled, isFullscreen, element*/
    7) {
      $: {
        if (isFullscreenEnabled)
          isFullscreen2 ? screenfull.request(element2) : screenfull.exit();
      }
    }
  };
  return [isFullscreen2, isFullscreenEnabled, element2];
}
var FullscreenManager = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, {
      element: 2,
      isFullscreen: 0,
      isFullscreenEnabled: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FullscreenManager",
      options,
      id: create_fragment20.name
    });
  }
  get element() {
    throw new Error("<FullscreenManager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<FullscreenManager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isFullscreen() {
    throw new Error("<FullscreenManager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isFullscreen(value) {
    throw new Error("<FullscreenManager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isFullscreenEnabled() {
    throw new Error("<FullscreenManager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isFullscreenEnabled(value) {
    throw new Error("<FullscreenManager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FullscreenManager_default = FullscreenManager;

// node_modules/svelte-video-player/src/libs/debounce.js
function debounce(fn, wait, callFirst) {
  var timeout;
  return function() {
    if (!wait) {
      return fn.apply(this, arguments);
    }
    var context = this;
    var args = arguments;
    var callNow = callFirst && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      timeout = null;
      if (!callNow) {
        return fn.apply(context, args);
      }
    }, wait);
    if (callNow) {
      return fn.apply(this, arguments);
    }
  };
}

// node_modules/svelte-video-player/src/IdleDetector.svelte
function create_fragment21(ctx) {
  let mounted;
  let dispose;
  const block = {
    c: noop,
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "pointermove",
            /*onActivity*/
            ctx[0],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "keydown",
            /*onActivity*/
            ctx[0],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("IdleDetector", slots, []);
  let { isIdle = false } = $$props;
  let timeout;
  function onActivity(e) {
    $$invalidate(1, isIdle = false);
    setIdleTimeout();
  }
  const setIdleTimeout = debounce(
    () => {
      clearTimeout(timeout);
      timeout = setTimeout(
        () => {
          $$invalidate(1, isIdle = true);
        },
        2e3
      );
    },
    250,
    true
  );
  onDestroy(() => {
    clearTimeout(timeout);
  });
  const writable_props = ["isIdle"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<IdleDetector> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("isIdle" in $$props2)
      $$invalidate(1, isIdle = $$props2.isIdle);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    debounce,
    isIdle,
    timeout,
    onActivity,
    setIdleTimeout
  });
  $$self.$inject_state = ($$props2) => {
    if ("isIdle" in $$props2)
      $$invalidate(1, isIdle = $$props2.isIdle);
    if ("timeout" in $$props2)
      timeout = $$props2.timeout;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [onActivity, isIdle];
}
var IdleDetector = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, { isIdle: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "IdleDetector",
      options,
      id: create_fragment21.name
    });
  }
  get isIdle() {
    throw new Error("<IdleDetector>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isIdle(value) {
    throw new Error("<IdleDetector>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var IdleDetector_default = IdleDetector;

// node_modules/svelte-video-player/src/ScrollDetector.svelte
function create_fragment22(ctx) {
  let mounted;
  let dispose;
  const block = {
    c: noop,
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (!mounted) {
        dispose = listen_dev(
          window,
          "scroll",
          /*onScroll*/
          ctx[0],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ScrollDetector", slots, []);
  let { isScrolling = false } = $$props;
  let timeout;
  function onScroll(e) {
    $$invalidate(1, isScrolling = true);
    setScrollEndTimeout();
  }
  const setScrollEndTimeout = debounce(
    () => {
      clearTimeout(timeout);
      timeout = setTimeout(
        () => {
          $$invalidate(1, isScrolling = false);
        },
        100
      );
    },
    100,
    true
  );
  onDestroy(() => {
    clearTimeout(timeout);
  });
  const writable_props = ["isScrolling"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ScrollDetector> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("isScrolling" in $$props2)
      $$invalidate(1, isScrolling = $$props2.isScrolling);
  };
  $$self.$capture_state = () => ({
    debounce,
    onDestroy,
    isScrolling,
    timeout,
    onScroll,
    setScrollEndTimeout
  });
  $$self.$inject_state = ($$props2) => {
    if ("isScrolling" in $$props2)
      $$invalidate(1, isScrolling = $$props2.isScrolling);
    if ("timeout" in $$props2)
      timeout = $$props2.timeout;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [onScroll, isScrolling];
}
var ScrollDetector = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, { isScrolling: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ScrollDetector",
      options,
      id: create_fragment22.name
    });
  }
  get isScrolling() {
    throw new Error("<ScrollDetector>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isScrolling(value) {
    throw new Error("<ScrollDetector>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ScrollDetector_default = ScrollDetector;

// node_modules/svelte-video-player/src/Time.svelte
var file16 = "node_modules/svelte-video-player/src/Time.svelte";
function add_css16(target) {
  append_styles(target, "svelte-1a30cmt", ".time.svelte-1a30cmt{position:relative;height:100%;text-align:center;display:flex;flex-direction:column;justify-content:center;margin-right:6px}.text.svelte-1a30cmt{position:relative;font-family:'Lucida Sans Typewriter', 'Lucida Console', monaco, 'Bitstream Vera Sans Mono', monospace;font-size:1rem;line-height:1rem;color:white}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGltZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBNkJFLG9CQUFNLENBQ0osUUFBUSxDQUFFLFFBQVEsQ0FDbEIsTUFBTSxDQUFFLElBQUksQ0FDWixVQUFVLENBQUUsTUFBTSxDQUNsQixPQUFPLENBQUUsSUFBSSxDQUNiLGNBQWMsQ0FBRSxNQUFNLENBQ3RCLGVBQWUsQ0FBRSxNQUFNLENBQ3ZCLFlBQVksQ0FBRSxHQUNoQixDQUNBLG9CQUFNLENBQ0osUUFBUSxDQUFFLFFBQVEsQ0FDbEIsV0FBVyxDQUFFLHdCQUF3QixDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQywwQkFBMEIsQ0FBQyxDQUFDLFNBQVMsQ0FDdEcsU0FBUyxDQUFFLElBQUksQ0FDZixXQUFXLENBQUUsSUFBSSxDQUNqQixLQUFLLENBQUUsS0FDVCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUaW1lLnN2ZWx0ZSJdfQ== */");
}
function create_fragment23(ctx) {
  let div1;
  let div0;
  let t;
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      t = text(
        /*ft*/
        ctx[0]
      );
      attr_dev(div0, "class", "text svelte-1a30cmt");
      add_location(div0, file16, 48, 2, 960);
      attr_dev(div1, "class", "time svelte-1a30cmt");
      add_location(div1, file16, 47, 0, 938);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, div0);
      append_dev(div0, t);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*ft*/
      1)
        set_data_dev(
          t,
          /*ft*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let hours;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Time", slots, []);
  let { duration } = $$props;
  let { currentTime } = $$props;
  let ft = 0;
  const setTime = throttle(
    () => {
      $$invalidate(0, ft = formatTime(currentTime, hours));
    },
    250,
    true
  );
  const formatTime = (seconds = 0, hours2 = false) => {
    let s = new Date(seconds * 1e3).toISOString().substr(11, 8);
    return hours2 ? s : s.substring(3);
  };
  $$self.$$.on_mount.push(function() {
    if (duration === void 0 && !("duration" in $$props || $$self.$$.bound[$$self.$$.props["duration"]])) {
      console.warn("<Time> was created without expected prop 'duration'");
    }
    if (currentTime === void 0 && !("currentTime" in $$props || $$self.$$.bound[$$self.$$.props["currentTime"]])) {
      console.warn("<Time> was created without expected prop 'currentTime'");
    }
  });
  const writable_props = ["duration", "currentTime"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Time> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("duration" in $$props2)
      $$invalidate(1, duration = $$props2.duration);
    if ("currentTime" in $$props2)
      $$invalidate(2, currentTime = $$props2.currentTime);
  };
  $$self.$capture_state = () => ({
    throttle,
    duration,
    currentTime,
    ft,
    setTime,
    formatTime,
    hours
  });
  $$self.$inject_state = ($$props2) => {
    if ("duration" in $$props2)
      $$invalidate(1, duration = $$props2.duration);
    if ("currentTime" in $$props2)
      $$invalidate(2, currentTime = $$props2.currentTime);
    if ("ft" in $$props2)
      $$invalidate(0, ft = $$props2.ft);
    if ("hours" in $$props2)
      hours = $$props2.hours;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*duration*/
    2) {
      $:
        hours = duration >= 3600;
    }
    if ($$self.$$.dirty & /*currentTime*/
    4) {
      $: {
        if (currentTime)
          setTime();
      }
    }
  };
  return [ft, duration, currentTime];
}
var Time = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, { duration: 1, currentTime: 2 }, add_css16);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Time",
      options,
      id: create_fragment23.name
    });
  }
  get duration() {
    throw new Error("<Time>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get currentTime() {
    throw new Error("<Time>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set currentTime(value) {
    throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Time_default = Time;

// node_modules/svelte-video-player/src/VideoPlayerClient.svelte
var file17 = "node_modules/svelte-video-player/src/VideoPlayerClient.svelte";
function add_css17(target) {
  append_styles(target, "svelte-1ai3mbf", "video::-webkit-media-controls{display:none !important}.aspect.svelte-1ai3mbf.svelte-1ai3mbf{position:relative;width:100%;height:0;padding-top:100%;overflow:hidden;border-radius:8px;-webkit-mask-image:-webkit-radial-gradient(white, black);mask-image:-webkit-radial-gradient(white, black)}.aspect.svelte-1ai3mbf>.svelte-1ai3mbf:first-child{position:absolute;top:0;right:0;bottom:0;left:0;outline:none}video.svelte-1ai3mbf.svelte-1ai3mbf{position:relative;width:100%;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmlkZW9QbGF5ZXJDbGllbnQuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTRPVSw2QkFBK0IsQ0FDckMsT0FBTyxDQUFFLElBQUksQ0FBQyxVQUNoQixDQUVBLHFDQUFRLENBQ04sUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsQ0FBQyxDQUNULFdBQVcsQ0FBRSxJQUFJLENBQ2pCLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLGFBQWEsQ0FBRSxHQUFHLENBRWxCLGtCQUFrQixDQUFFLHdCQUF3QixLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FDekQsVUFBVSxDQUFFLHdCQUF3QixLQUFLLENBQUMsQ0FBQyxLQUFLLENBQ2xELENBRUEsc0JBQU8sZ0JBQUcsWUFBYSxDQUNyQixRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsQ0FBQyxDQUNOLEtBQUssQ0FBRSxDQUFDLENBQ1IsTUFBTSxDQUFFLENBQUMsQ0FDVCxJQUFJLENBQUUsQ0FBQyxDQUNQLE9BQU8sQ0FBRSxJQUNYLENBRUEsbUNBQU0sQ0FDSixRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUNWIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlZpZGVvUGxheWVyQ2xpZW50LnN2ZWx0ZSJdfQ== */");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[84] = list[i].src;
  child_ctx[85] = list[i].type;
  return child_ctx;
}
function create_catch_block(ctx) {
  let p;
  let t_value = (
    /*error*/
    ctx[88] + ""
  );
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text(t_value);
      set_style(p, "color", "red");
      attr_dev(p, "class", "svelte-1ai3mbf");
      add_location(p, file17, 346, 4, 10864);
    },
    m: function mount(target, anchor) {
      insert_dev(target, p, anchor);
      append_dev(p, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*poster*/
      4 && t_value !== (t_value = /*error*/
      ctx2[88] + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_catch_block.name,
    type: "catch",
    source: "(346:2) {:catch error}",
    ctx
  });
  return block;
}
function create_then_block(ctx) {
  let div;
  let video;
  let track;
  let p;
  let video_updating = false;
  let video_animationframe;
  let video_is_paused = true;
  let t1;
  let t2;
  let controls;
  let div_id_value;
  let div_tabindex_value;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(
    /*_sources*/
    ctx[31]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  function video_timeupdate_handler() {
    cancelAnimationFrame(video_animationframe);
    if (!video.paused) {
      video_animationframe = raf(video_timeupdate_handler);
      video_updating = true;
    }
    ctx[61].call(video);
  }
  let if_block = (
    /*poster*/
    ctx[2] && /*isPosterVisible*/
    ctx[30] && create_if_block_2(ctx)
  );
  controls = new Controls_default({
    props: {
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      video = element("video");
      track = element("track");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      p = element("p");
      p.textContent = "Sorry, your browser doesn't support HTML5 videos.";
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      create_component(controls.$$.fragment);
      attr_dev(track, "kind", "captions");
      add_location(track, file17, 306, 8, 9501);
      add_location(p, file17, 310, 8, 9631);
      attr_dev(
        video,
        "width",
        /*width*/
        ctx[0]
      );
      attr_dev(
        video,
        "height",
        /*height*/
        ctx[1]
      );
      attr_dev(video, "preload", "none");
      attr_dev(video, "class", "svelte-1ai3mbf");
      if (
        /*currentTime*/
        ctx[9] === void 0 || /*played*/
        ctx[21] === void 0 || /*ended*/
        ctx[11] === void 0
      )
        add_render_callback(video_timeupdate_handler);
      if (
        /*duration*/
        ctx[19] === void 0
      )
        add_render_callback(() => (
          /*video_durationchange_handler*/
          ctx[62].call(video)
        ));
      if (
        /*buffered*/
        ctx[20] === void 0
      )
        add_render_callback(() => (
          /*video_progress_handler*/
          ctx[63].call(video)
        ));
      if (
        /*buffered*/
        ctx[20] === void 0
      )
        add_render_callback(() => (
          /*video_loadedmetadata_handler*/
          ctx[64].call(video)
        ));
      if (
        /*seeking*/
        ctx[10] === void 0
      )
        add_render_callback(() => (
          /*video_seeking_seeked_handler*/
          ctx[65].call(video)
        ));
      if (
        /*ended*/
        ctx[11] === void 0
      )
        add_render_callback(() => (
          /*video_ended_handler*/
          ctx[66].call(video)
        ));
      add_location(video, file17, 289, 6, 9066);
      attr_dev(div, "id", div_id_value = "video-player-" + uid());
      attr_dev(div, "tabindex", div_tabindex_value = /*isVideoData*/
      ctx[14] ? "0" : "-1");
      attr_dev(div, "class", "svelte-1ai3mbf");
      add_location(div, file17, 282, 4, 8813);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, video);
      append_dev(video, track);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(video, null);
        }
      }
      append_dev(video, p);
      ctx[60](video);
      if (!isNaN(
        /*volume*/
        ctx[13]
      )) {
        video.volume = /*volume*/
        ctx[13];
      }
      append_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      append_dev(div, t2);
      mount_component(controls, div, null);
      ctx[74](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(video, "timeupdate", video_timeupdate_handler),
          listen_dev(
            video,
            "durationchange",
            /*video_durationchange_handler*/
            ctx[62]
          ),
          listen_dev(
            video,
            "progress",
            /*video_progress_handler*/
            ctx[63]
          ),
          listen_dev(
            video,
            "loadedmetadata",
            /*video_loadedmetadata_handler*/
            ctx[64]
          ),
          listen_dev(
            video,
            "seeking",
            /*video_seeking_seeked_handler*/
            ctx[65]
          ),
          listen_dev(
            video,
            "seeked",
            /*video_seeking_seeked_handler*/
            ctx[65]
          ),
          listen_dev(
            video,
            "ended",
            /*video_ended_handler*/
            ctx[66]
          ),
          listen_dev(
            video,
            "play",
            /*video_play_pause_handler*/
            ctx[67]
          ),
          listen_dev(
            video,
            "pause",
            /*video_play_pause_handler*/
            ctx[67]
          ),
          listen_dev(
            video,
            "volumechange",
            /*video_volumechange_handler*/
            ctx[68]
          ),
          listen_dev(
            video,
            "loadeddata",
            /*onVideoLoadedData*/
            ctx[33],
            { once: true },
            false,
            false,
            false
          ),
          listen_dev(video, "play", onPlay, false, false, false, false),
          listen_dev(
            video,
            "playing",
            /*onVideoPlaying*/
            ctx[34],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            video,
            "waiting",
            /*onVideoWaiting*/
            ctx[35],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "pointerover",
            /*onPlayerPointerOver*/
            ctx[36],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "pointerout",
            /*onPlayerPointerOut*/
            ctx[37],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "pointerup",
            /*onPlayerPointerUp*/
            ctx[38],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[1] & /*_sources*/
      1) {
        each_value = ensure_array_like_dev(
          /*_sources*/
          ctx2[31]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(video, p);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty[0] & /*width*/
      1) {
        attr_dev(
          video,
          "width",
          /*width*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*height*/
      2) {
        attr_dev(
          video,
          "height",
          /*height*/
          ctx2[1]
        );
      }
      if (!video_updating && dirty[0] & /*currentTime*/
      512 && !isNaN(
        /*currentTime*/
        ctx2[9]
      )) {
        video.currentTime = /*currentTime*/
        ctx2[9];
      }
      video_updating = false;
      if (dirty[0] & /*paused*/
      4096 && video_is_paused !== (video_is_paused = /*paused*/
      ctx2[12])) {
        video[video_is_paused ? "pause" : "play"]();
      }
      if (dirty[0] & /*volume*/
      8192 && !isNaN(
        /*volume*/
        ctx2[13]
      )) {
        video.volume = /*volume*/
        ctx2[13];
      }
      if (
        /*poster*/
        ctx2[2] && /*isPosterVisible*/
        ctx2[30]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*poster, isPosterVisible*/
          1073741828) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const controls_changes = {};
      if (dirty[0] & /*isCenterIconVisibile, isSpinnerVisible, isBuffering, isBottomControlsVisible, isPointerOverControls, isFullscreen, isFullscreenEnabled, volume, muted, duration, currentTime, timeDisplay, buffered, played, paused, isScrubbing*/
      1039839872 | dirty[2] & /*$$scope*/
      134217728) {
        controls_changes.$$scope = { dirty, ctx: ctx2 };
      }
      controls.$set(controls_changes);
      if (!current || dirty[0] & /*isVideoData*/
      16384 && div_tabindex_value !== (div_tabindex_value = /*isVideoData*/
      ctx2[14] ? "0" : "-1")) {
        attr_dev(div, "tabindex", div_tabindex_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(controls.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(controls.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
      ctx[60](null);
      if (if_block)
        if_block.d();
      destroy_component(controls);
      ctx[74](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_then_block.name,
    type: "then",
    source: "(282:2) {:then}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let source_1;
  let source_1_src_value;
  let source_1_type_value;
  const block = {
    c: function create() {
      source_1 = element("source");
      if (!src_url_equal(source_1.src, source_1_src_value = /*src*/
      ctx[84]))
        attr_dev(source_1, "src", source_1_src_value);
      attr_dev(source_1, "type", source_1_type_value = /*type*/
      ctx[85]);
      add_location(source_1, file17, 308, 10, 9581);
    },
    m: function mount(target, anchor) {
      insert_dev(target, source_1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[1] & /*_sources*/
      1 && !src_url_equal(source_1.src, source_1_src_value = /*src*/
      ctx2[84])) {
        attr_dev(source_1, "src", source_1_src_value);
      }
      if (dirty[1] & /*_sources*/
      1 && source_1_type_value !== (source_1_type_value = /*type*/
      ctx2[85])) {
        attr_dev(source_1, "type", source_1_type_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(source_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(308:8) {#each _sources as { src, type }}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let poster_1;
  let current;
  poster_1 = new Poster_default({
    props: { src: (
      /*poster*/
      ctx[2]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(poster_1.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(poster_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const poster_1_changes = {};
      if (dirty[0] & /*poster*/
      4)
        poster_1_changes.src = /*poster*/
        ctx2[2];
      poster_1.$set(poster_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(poster_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(poster_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(poster_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(314:6) {#if poster && isPosterVisible}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let time;
  let current;
  time = new Time_default({
    props: {
      duration: (
        /*duration*/
        ctx[19]
      ),
      currentTime: (
        /*currentTime*/
        ctx[9]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(time.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(time, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const time_changes = {};
      if (dirty[0] & /*duration*/
      524288)
        time_changes.duration = /*duration*/
        ctx2[19];
      if (dirty[0] & /*currentTime*/
      512)
        time_changes.currentTime = /*currentTime*/
        ctx2[9];
      time.$set(time_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(time.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(time.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(time, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(330:10) {#if timeDisplay}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let fullscreenbutton;
  let current;
  fullscreenbutton = new FullscreenButton_default({
    props: { isFullscreen: (
      /*isFullscreen*/
      ctx[24]
    ) },
    $$inline: true
  });
  fullscreenbutton.$on(
    "pointerup",
    /*onFullscreenButtonPointerUp*/
    ctx[41]
  );
  const block = {
    c: function create() {
      create_component(fullscreenbutton.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(fullscreenbutton, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const fullscreenbutton_changes = {};
      if (dirty[0] & /*isFullscreen*/
      16777216)
        fullscreenbutton_changes.isFullscreen = /*isFullscreen*/
        ctx2[24];
      fullscreenbutton.$set(fullscreenbutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(fullscreenbutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(fullscreenbutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(fullscreenbutton, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(335:10) {#if isFullscreenEnabled}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let playpausebutton;
  let t0;
  let playbar;
  let updating_currentTime;
  let updating_paused;
  let updating_isScrubbing;
  let t1;
  let t2;
  let volumebutton;
  let t3;
  let volumecontrol;
  let updating_volume;
  let t4;
  let if_block1_anchor;
  let current;
  playpausebutton = new PlayPauseButton_default({
    props: { paused: (
      /*paused*/
      ctx[12]
    ) },
    $$inline: true
  });
  playpausebutton.$on(
    "pointerup",
    /*onPlayPauseButtonPointerUp*/
    ctx[43]
  );
  function playbar_currentTime_binding(value) {
    ctx[69](value);
  }
  function playbar_paused_binding(value) {
    ctx[70](value);
  }
  function playbar_isScrubbing_binding(value) {
    ctx[71](value);
  }
  let playbar_props = {
    duration: (
      /*duration*/
      ctx[19]
    ),
    buffered: (
      /*buffered*/
      ctx[20]
    ),
    played: (
      /*played*/
      ctx[21]
    ),
    isBottomControlsVisible: (
      /*isBottomControlsVisible*/
      ctx[27]
    )
  };
  if (
    /*currentTime*/
    ctx[9] !== void 0
  ) {
    playbar_props.currentTime = /*currentTime*/
    ctx[9];
  }
  if (
    /*paused*/
    ctx[12] !== void 0
  ) {
    playbar_props.paused = /*paused*/
    ctx[12];
  }
  if (
    /*isScrubbing*/
    ctx[17] !== void 0
  ) {
    playbar_props.isScrubbing = /*isScrubbing*/
    ctx[17];
  }
  playbar = new Playbar_default({ props: playbar_props, $$inline: true });
  binding_callbacks.push(() => bind(playbar, "currentTime", playbar_currentTime_binding));
  binding_callbacks.push(() => bind(playbar, "paused", playbar_paused_binding));
  binding_callbacks.push(() => bind(playbar, "isScrubbing", playbar_isScrubbing_binding));
  playbar.$on(
    "pointerup",
    /*onPlaybarPointerUp*/
    ctx[42]
  );
  let if_block0 = (
    /*timeDisplay*/
    ctx[7] && create_if_block_1(ctx)
  );
  volumebutton = new VolumeButton_default({
    props: { muted: (
      /*muted*/
      ctx[26]
    ) },
    $$inline: true
  });
  volumebutton.$on(
    "pointerup",
    /*onVolumeButtonPointerUp*/
    ctx[44]
  );
  function volumecontrol_volume_binding(value) {
    ctx[72](value);
  }
  let volumecontrol_props = {};
  if (
    /*volume*/
    ctx[13] !== void 0
  ) {
    volumecontrol_props.volume = /*volume*/
    ctx[13];
  }
  volumecontrol = new VolumeControl_default({
    props: volumecontrol_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(volumecontrol, "volume", volumecontrol_volume_binding));
  let if_block1 = (
    /*isFullscreenEnabled*/
    ctx[23] && create_if_block4(ctx)
  );
  const block = {
    c: function create() {
      create_component(playpausebutton.$$.fragment);
      t0 = space();
      create_component(playbar.$$.fragment);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      create_component(volumebutton.$$.fragment);
      t3 = space();
      create_component(volumecontrol.$$.fragment);
      t4 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(playpausebutton, target, anchor);
      insert_dev(target, t0, anchor);
      mount_component(playbar, target, anchor);
      insert_dev(target, t1, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t2, anchor);
      mount_component(volumebutton, target, anchor);
      insert_dev(target, t3, anchor);
      mount_component(volumecontrol, target, anchor);
      insert_dev(target, t4, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const playpausebutton_changes = {};
      if (dirty[0] & /*paused*/
      4096)
        playpausebutton_changes.paused = /*paused*/
        ctx2[12];
      playpausebutton.$set(playpausebutton_changes);
      const playbar_changes = {};
      if (dirty[0] & /*duration*/
      524288)
        playbar_changes.duration = /*duration*/
        ctx2[19];
      if (dirty[0] & /*buffered*/
      1048576)
        playbar_changes.buffered = /*buffered*/
        ctx2[20];
      if (dirty[0] & /*played*/
      2097152)
        playbar_changes.played = /*played*/
        ctx2[21];
      if (dirty[0] & /*isBottomControlsVisible*/
      134217728)
        playbar_changes.isBottomControlsVisible = /*isBottomControlsVisible*/
        ctx2[27];
      if (!updating_currentTime && dirty[0] & /*currentTime*/
      512) {
        updating_currentTime = true;
        playbar_changes.currentTime = /*currentTime*/
        ctx2[9];
        add_flush_callback(() => updating_currentTime = false);
      }
      if (!updating_paused && dirty[0] & /*paused*/
      4096) {
        updating_paused = true;
        playbar_changes.paused = /*paused*/
        ctx2[12];
        add_flush_callback(() => updating_paused = false);
      }
      if (!updating_isScrubbing && dirty[0] & /*isScrubbing*/
      131072) {
        updating_isScrubbing = true;
        playbar_changes.isScrubbing = /*isScrubbing*/
        ctx2[17];
        add_flush_callback(() => updating_isScrubbing = false);
      }
      playbar.$set(playbar_changes);
      if (
        /*timeDisplay*/
        ctx2[7]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*timeDisplay*/
          128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t2.parentNode, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const volumebutton_changes = {};
      if (dirty[0] & /*muted*/
      67108864)
        volumebutton_changes.muted = /*muted*/
        ctx2[26];
      volumebutton.$set(volumebutton_changes);
      const volumecontrol_changes = {};
      if (!updating_volume && dirty[0] & /*volume*/
      8192) {
        updating_volume = true;
        volumecontrol_changes.volume = /*volume*/
        ctx2[13];
        add_flush_callback(() => updating_volume = false);
      }
      volumecontrol.$set(volumecontrol_changes);
      if (
        /*isFullscreenEnabled*/
        ctx2[23]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*isFullscreenEnabled*/
          8388608) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(playpausebutton.$$.fragment, local);
      transition_in(playbar.$$.fragment, local);
      transition_in(if_block0);
      transition_in(volumebutton.$$.fragment, local);
      transition_in(volumecontrol.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(playpausebutton.$$.fragment, local);
      transition_out(playbar.$$.fragment, local);
      transition_out(if_block0);
      transition_out(volumebutton.$$.fragment, local);
      transition_out(volumecontrol.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
        detach_dev(t4);
        detach_dev(if_block1_anchor);
      }
      destroy_component(playpausebutton, detaching);
      destroy_component(playbar, detaching);
      if (if_block0)
        if_block0.d(detaching);
      destroy_component(volumebutton, detaching);
      destroy_component(volumecontrol, detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(319:8) <BottomControls hidden={!isBottomControlsVisible} bind:isPointerOver={isPointerOverControls}>",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let bottomcontrols;
  let updating_isPointerOver;
  let t;
  let centericons;
  let current;
  function bottomcontrols_isPointerOver_binding(value) {
    ctx[73](value);
  }
  let bottomcontrols_props = {
    hidden: !/*isBottomControlsVisible*/
    ctx[27],
    $$slots: { default: [create_default_slot_1] },
    $$scope: { ctx }
  };
  if (
    /*isPointerOverControls*/
    ctx[22] !== void 0
  ) {
    bottomcontrols_props.isPointerOver = /*isPointerOverControls*/
    ctx[22];
  }
  bottomcontrols = new BottomControls_default({
    props: bottomcontrols_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(bottomcontrols, "isPointerOver", bottomcontrols_isPointerOver_binding));
  centericons = new CenterIcons_default({
    props: {
      isIconVisible: (
        /*isCenterIconVisibile*/
        ctx[28]
      ),
      isSpinnerVisible: (
        /*isSpinnerVisible*/
        ctx[29]
      ),
      isBuffering: (
        /*isBuffering*/
        ctx[15]
      )
    },
    $$inline: true
  });
  centericons.$on(
    "togglePause",
    /*togglePause*/
    ctx[45]
  );
  const block = {
    c: function create() {
      create_component(bottomcontrols.$$.fragment);
      t = space();
      create_component(centericons.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(bottomcontrols, target, anchor);
      insert_dev(target, t, anchor);
      mount_component(centericons, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const bottomcontrols_changes = {};
      if (dirty[0] & /*isBottomControlsVisible*/
      134217728)
        bottomcontrols_changes.hidden = !/*isBottomControlsVisible*/
        ctx2[27];
      if (dirty[0] & /*isFullscreen, isFullscreenEnabled, volume, muted, duration, currentTime, timeDisplay, buffered, played, isBottomControlsVisible, paused, isScrubbing*/
      230306432 | dirty[2] & /*$$scope*/
      134217728) {
        bottomcontrols_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_isPointerOver && dirty[0] & /*isPointerOverControls*/
      4194304) {
        updating_isPointerOver = true;
        bottomcontrols_changes.isPointerOver = /*isPointerOverControls*/
        ctx2[22];
        add_flush_callback(() => updating_isPointerOver = false);
      }
      bottomcontrols.$set(bottomcontrols_changes);
      const centericons_changes = {};
      if (dirty[0] & /*isCenterIconVisibile*/
      268435456)
        centericons_changes.isIconVisible = /*isCenterIconVisibile*/
        ctx2[28];
      if (dirty[0] & /*isSpinnerVisible*/
      536870912)
        centericons_changes.isSpinnerVisible = /*isSpinnerVisible*/
        ctx2[29];
      if (dirty[0] & /*isBuffering*/
      32768)
        centericons_changes.isBuffering = /*isBuffering*/
        ctx2[15];
      centericons.$set(centericons_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(bottomcontrols.$$.fragment, local);
      transition_in(centericons.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(bottomcontrols.$$.fragment, local);
      transition_out(centericons.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(bottomcontrols, detaching);
      destroy_component(centericons, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(318:6) <Controls>",
    ctx
  });
  return block;
}
function create_pending_block(ctx) {
  let div;
  let spinner;
  let current;
  spinner = new Spinner_default({
    props: {
      color: (
        /*iconColor*/
        ctx[4]
      ),
      size: "60px"
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(spinner.$$.fragment);
      attr_dev(div, "class", "svelte-1ai3mbf");
      add_location(div, file17, 278, 4, 8730);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(spinner, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const spinner_changes = {};
      if (dirty[0] & /*iconColor*/
      16)
        spinner_changes.color = /*iconColor*/
        ctx2[4];
      spinner.$set(spinner_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(spinner);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_pending_block.name,
    type: "pending",
    source: "(278:31)       <div>        <Spinner color={iconColor}",
    ctx
  });
  return block;
}
function create_fragment24(ctx) {
  let div;
  let promise;
  let t0;
  let idledetector;
  let updating_isIdle;
  let t1;
  let scrolldetector;
  let updating_isScrolling;
  let t2;
  let fullscreenmanager;
  let updating_isFullscreenEnabled;
  let updating_isFullscreen;
  let current;
  let mounted;
  let dispose;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    error: 88,
    blocks: [, , ,]
  };
  handle_promise(promise = preloadImage(
    /*poster*/
    ctx[2]
  ), info);
  function idledetector_isIdle_binding(value) {
    ctx[75](value);
  }
  let idledetector_props = {};
  if (
    /*isIdle*/
    ctx[16] !== void 0
  ) {
    idledetector_props.isIdle = /*isIdle*/
    ctx[16];
  }
  idledetector = new IdleDetector_default({
    props: idledetector_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(idledetector, "isIdle", idledetector_isIdle_binding));
  function scrolldetector_isScrolling_binding(value) {
    ctx[76](value);
  }
  let scrolldetector_props = {};
  if (
    /*isScrolling*/
    ctx[25] !== void 0
  ) {
    scrolldetector_props.isScrolling = /*isScrolling*/
    ctx[25];
  }
  scrolldetector = new ScrollDetector_default({
    props: scrolldetector_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(scrolldetector, "isScrolling", scrolldetector_isScrolling_binding));
  function fullscreenmanager_isFullscreenEnabled_binding(value) {
    ctx[77](value);
  }
  function fullscreenmanager_isFullscreen_binding(value) {
    ctx[78](value);
  }
  let fullscreenmanager_props = { element: (
    /*videoPlayerElement*/
    ctx[18]
  ) };
  if (
    /*isFullscreenEnabled*/
    ctx[23] !== void 0
  ) {
    fullscreenmanager_props.isFullscreenEnabled = /*isFullscreenEnabled*/
    ctx[23];
  }
  if (
    /*isFullscreen*/
    ctx[24] !== void 0
  ) {
    fullscreenmanager_props.isFullscreen = /*isFullscreen*/
    ctx[24];
  }
  fullscreenmanager = new FullscreenManager_default({
    props: fullscreenmanager_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(fullscreenmanager, "isFullscreenEnabled", fullscreenmanager_isFullscreenEnabled_binding));
  binding_callbacks.push(() => bind(fullscreenmanager, "isFullscreen", fullscreenmanager_isFullscreen_binding));
  const block = {
    c: function create() {
      div = element("div");
      info.block.c();
      t0 = space();
      create_component(idledetector.$$.fragment);
      t1 = space();
      create_component(scrolldetector.$$.fragment);
      t2 = space();
      create_component(fullscreenmanager.$$.fragment);
      attr_dev(div, "class", "aspect svelte-1ai3mbf");
      set_style(
        div,
        "padding-top",
        /*aspectRatio*/
        ctx[6] * 100 + "%"
      );
      set_style(
        div,
        "background-color",
        /*playerBgColor*/
        ctx[3]
      );
      set_style(
        div,
        "border-radius",
        /*borderRadius*/
        ctx[5]
      );
      add_location(div, file17, 274, 0, 8560);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      info.block.m(div, info.anchor = null);
      info.mount = () => div;
      info.anchor = t0;
      append_dev(div, t0);
      mount_component(idledetector, div, null);
      append_dev(div, t1);
      mount_component(scrolldetector, div, null);
      append_dev(div, t2);
      mount_component(fullscreenmanager, div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "keydown",
            /*onWindowKeyDown*/
            ctx[39],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "keyup",
            /*onWindowKeyUp*/
            ctx[40],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty[0] & /*poster*/
      4 && promise !== (promise = preloadImage(
        /*poster*/
        ctx[2]
      )) && handle_promise(promise, info)) {
      } else {
        update_await_block_branch(info, ctx, dirty);
      }
      const idledetector_changes = {};
      if (!updating_isIdle && dirty[0] & /*isIdle*/
      65536) {
        updating_isIdle = true;
        idledetector_changes.isIdle = /*isIdle*/
        ctx[16];
        add_flush_callback(() => updating_isIdle = false);
      }
      idledetector.$set(idledetector_changes);
      const scrolldetector_changes = {};
      if (!updating_isScrolling && dirty[0] & /*isScrolling*/
      33554432) {
        updating_isScrolling = true;
        scrolldetector_changes.isScrolling = /*isScrolling*/
        ctx[25];
        add_flush_callback(() => updating_isScrolling = false);
      }
      scrolldetector.$set(scrolldetector_changes);
      const fullscreenmanager_changes = {};
      if (dirty[0] & /*videoPlayerElement*/
      262144)
        fullscreenmanager_changes.element = /*videoPlayerElement*/
        ctx[18];
      if (!updating_isFullscreenEnabled && dirty[0] & /*isFullscreenEnabled*/
      8388608) {
        updating_isFullscreenEnabled = true;
        fullscreenmanager_changes.isFullscreenEnabled = /*isFullscreenEnabled*/
        ctx[23];
        add_flush_callback(() => updating_isFullscreenEnabled = false);
      }
      if (!updating_isFullscreen && dirty[0] & /*isFullscreen*/
      16777216) {
        updating_isFullscreen = true;
        fullscreenmanager_changes.isFullscreen = /*isFullscreen*/
        ctx[24];
        add_flush_callback(() => updating_isFullscreen = false);
      }
      fullscreenmanager.$set(fullscreenmanager_changes);
      if (!current || dirty[0] & /*aspectRatio*/
      64) {
        set_style(
          div,
          "padding-top",
          /*aspectRatio*/
          ctx[6] * 100 + "%"
        );
      }
      if (!current || dirty[0] & /*playerBgColor*/
      8) {
        set_style(
          div,
          "background-color",
          /*playerBgColor*/
          ctx[3]
        );
      }
      if (!current || dirty[0] & /*borderRadius*/
      32) {
        set_style(
          div,
          "border-radius",
          /*borderRadius*/
          ctx[5]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(info.block);
      transition_in(idledetector.$$.fragment, local);
      transition_in(scrolldetector.$$.fragment, local);
      transition_in(fullscreenmanager.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < 3; i += 1) {
        const block2 = info.blocks[i];
        transition_out(block2);
      }
      transition_out(idledetector.$$.fragment, local);
      transition_out(scrolldetector.$$.fragment, local);
      transition_out(fullscreenmanager.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      info.block.d();
      info.token = null;
      info = null;
      destroy_component(idledetector);
      destroy_component(scrolldetector);
      destroy_component(fullscreenmanager);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var currentVideo;
function onPlay(e) {
  if (currentVideo && currentVideo !== e.target)
    currentVideo.pause();
  currentVideo = e.target;
}
function instance24($$self, $$props, $$invalidate) {
  let _sources;
  let _skipSeconds;
  let muted;
  let isPosterVisible;
  let isBottomControlsVisible;
  let isSpinnerVisible;
  let isCenterIconVisibile;
  let $config;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VideoPlayerClient", slots, []);
  let { width } = $$props;
  let { height } = $$props;
  let { poster } = $$props;
  let { source } = $$props;
  let { controlsHeight } = $$props;
  let { trackHeight } = $$props;
  let { thumbSize } = $$props;
  let { centerIconSize } = $$props;
  let { playerBgColor } = $$props;
  let { color } = $$props;
  let { focusColor } = $$props;
  let { barsBgColor } = $$props;
  let { iconColor } = $$props;
  let { bufferedColor } = $$props;
  let { chunkBars } = $$props;
  let { borderRadius } = $$props;
  let { loop } = $$props;
  let { skipSeconds } = $$props;
  let { aspectRatio } = $$props;
  let { controlsOnPause } = $$props;
  let { timeDisplay } = $$props;
  const config = writable({});
  validate_store(config, "config");
  component_subscribe($$self, config, (value) => $$invalidate(82, $config = value));
  setContext("config", config);
  let videoPlayerElement;
  let videoElement;
  let currentTime = 0;
  let duration;
  let buffered = [];
  let played = [];
  let seeking;
  let ended;
  let paused = true;
  let volume = 1;
  let muteVolume = 1;
  let isVideoData = false;
  let isPointerOverVideo = false;
  let isPointerOverControls = false;
  let isBuffering = false;
  let isFullscreenEnabled = false;
  let isFullscreen2 = false;
  let isIdle = false;
  let isScrolling = false;
  let isScrubbing = false;
  let isKeyDown = false;
  function onVideoLoadedData(e) {
    $$invalidate(14, isVideoData = true);
  }
  function onVideoPlaying(e) {
    $$invalidate(15, isBuffering = false);
  }
  function onVideoWaiting(e) {
    $$invalidate(15, isBuffering = true);
  }
  function onPlayerPointerOver(e) {
    $$invalidate(59, isPointerOverVideo = true);
  }
  function onPlayerPointerOut(e) {
    $$invalidate(59, isPointerOverVideo = false);
  }
  function onPlayerPointerUp(e) {
    if (!isPointerOverControls && !isScrolling) {
      $$invalidate(12, paused = !paused);
    }
  }
  function onWindowKeyDown(e) {
    if (currentVideo !== videoElement)
      return;
    switch (e.code) {
      case "Tab":
        if (isKeyDown)
          break;
        if (!isBottomControlsVisible) {
          e.stopPropagation();
          e.preventDefault();
          $$invalidate(27, isBottomControlsVisible = true);
        }
        break;
      case "Space":
        if (isKeyDown)
          break;
        e.preventDefault();
        currentVideo.paused ? currentVideo.play() : currentVideo.pause();
        break;
      case "ArrowLeft":
        e.preventDefault();
        timeJump(
          true
          // Prevent page scroll
        );
        break;
      case "ArrowRight":
        e.preventDefault();
        timeJump();
        break;
    }
    isKeyDown = true;
  }
  function onWindowKeyUp(e) {
    if (currentVideo !== videoElement)
      return;
    isKeyDown = false;
  }
  function timeJump(back) {
    const t = videoElement.currentTime;
    const d = videoElement.duration;
    if (back)
      $$invalidate(8, videoElement.currentTime = t > _skipSeconds ? t - _skipSeconds : 0, videoElement);
    else
      $$invalidate(8, videoElement.currentTime = t + _skipSeconds < d ? t + _skipSeconds : d - 0.2, videoElement);
  }
  function onFullscreenButtonPointerUp(e) {
    $$invalidate(24, isFullscreen2 = !isFullscreen2);
  }
  function onPlaybarPointerUp(e) {
    if (videoElement != videoElement)
      $$invalidate(12, paused = false);
  }
  function onPlayPauseButtonPointerUp(e) {
    $$invalidate(12, paused = !paused);
  }
  function onVolumeButtonPointerUp(e) {
    if (!muted) {
      muteVolume = volume;
      $$invalidate(13, volume = 0);
    } else {
      $$invalidate(13, volume = muteVolume);
      muteVolume = 1;
    }
  }
  function togglePause() {
    $$invalidate(12, paused = !paused);
  }
  $$self.$$.on_mount.push(function() {
    if (width === void 0 && !("width" in $$props || $$self.$$.bound[$$self.$$.props["width"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'width'");
    }
    if (height === void 0 && !("height" in $$props || $$self.$$.bound[$$self.$$.props["height"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'height'");
    }
    if (poster === void 0 && !("poster" in $$props || $$self.$$.bound[$$self.$$.props["poster"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'poster'");
    }
    if (source === void 0 && !("source" in $$props || $$self.$$.bound[$$self.$$.props["source"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'source'");
    }
    if (controlsHeight === void 0 && !("controlsHeight" in $$props || $$self.$$.bound[$$self.$$.props["controlsHeight"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'controlsHeight'");
    }
    if (trackHeight === void 0 && !("trackHeight" in $$props || $$self.$$.bound[$$self.$$.props["trackHeight"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'trackHeight'");
    }
    if (thumbSize === void 0 && !("thumbSize" in $$props || $$self.$$.bound[$$self.$$.props["thumbSize"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'thumbSize'");
    }
    if (centerIconSize === void 0 && !("centerIconSize" in $$props || $$self.$$.bound[$$self.$$.props["centerIconSize"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'centerIconSize'");
    }
    if (playerBgColor === void 0 && !("playerBgColor" in $$props || $$self.$$.bound[$$self.$$.props["playerBgColor"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'playerBgColor'");
    }
    if (color === void 0 && !("color" in $$props || $$self.$$.bound[$$self.$$.props["color"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'color'");
    }
    if (focusColor === void 0 && !("focusColor" in $$props || $$self.$$.bound[$$self.$$.props["focusColor"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'focusColor'");
    }
    if (barsBgColor === void 0 && !("barsBgColor" in $$props || $$self.$$.bound[$$self.$$.props["barsBgColor"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'barsBgColor'");
    }
    if (iconColor === void 0 && !("iconColor" in $$props || $$self.$$.bound[$$self.$$.props["iconColor"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'iconColor'");
    }
    if (bufferedColor === void 0 && !("bufferedColor" in $$props || $$self.$$.bound[$$self.$$.props["bufferedColor"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'bufferedColor'");
    }
    if (chunkBars === void 0 && !("chunkBars" in $$props || $$self.$$.bound[$$self.$$.props["chunkBars"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'chunkBars'");
    }
    if (borderRadius === void 0 && !("borderRadius" in $$props || $$self.$$.bound[$$self.$$.props["borderRadius"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'borderRadius'");
    }
    if (loop === void 0 && !("loop" in $$props || $$self.$$.bound[$$self.$$.props["loop"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'loop'");
    }
    if (skipSeconds === void 0 && !("skipSeconds" in $$props || $$self.$$.bound[$$self.$$.props["skipSeconds"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'skipSeconds'");
    }
    if (aspectRatio === void 0 && !("aspectRatio" in $$props || $$self.$$.bound[$$self.$$.props["aspectRatio"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'aspectRatio'");
    }
    if (controlsOnPause === void 0 && !("controlsOnPause" in $$props || $$self.$$.bound[$$self.$$.props["controlsOnPause"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'controlsOnPause'");
    }
    if (timeDisplay === void 0 && !("timeDisplay" in $$props || $$self.$$.bound[$$self.$$.props["timeDisplay"]])) {
      console.warn("<VideoPlayerClient> was created without expected prop 'timeDisplay'");
    }
  });
  const writable_props = [
    "width",
    "height",
    "poster",
    "source",
    "controlsHeight",
    "trackHeight",
    "thumbSize",
    "centerIconSize",
    "playerBgColor",
    "color",
    "focusColor",
    "barsBgColor",
    "iconColor",
    "bufferedColor",
    "chunkBars",
    "borderRadius",
    "loop",
    "skipSeconds",
    "aspectRatio",
    "controlsOnPause",
    "timeDisplay"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VideoPlayerClient> was created with unknown prop '${key}'`);
  });
  function video_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      videoElement = $$value;
      $$invalidate(8, videoElement);
    });
  }
  function video_timeupdate_handler() {
    currentTime = this.currentTime;
    played = time_ranges_to_array(this.played);
    ended = this.ended;
    $$invalidate(9, currentTime), $$invalidate(11, ended), $$invalidate(56, loop), $$invalidate(8, videoElement);
    $$invalidate(21, played);
    $$invalidate(11, ended);
  }
  function video_durationchange_handler() {
    duration = this.duration;
    $$invalidate(19, duration);
  }
  function video_progress_handler() {
    buffered = time_ranges_to_array(this.buffered);
    $$invalidate(20, buffered);
  }
  function video_loadedmetadata_handler() {
    buffered = time_ranges_to_array(this.buffered);
    $$invalidate(20, buffered);
  }
  function video_seeking_seeked_handler() {
    seeking = this.seeking;
    $$invalidate(10, seeking);
  }
  function video_ended_handler() {
    ended = this.ended;
    $$invalidate(11, ended);
  }
  function video_play_pause_handler() {
    paused = this.paused;
    $$invalidate(12, paused);
  }
  function video_volumechange_handler() {
    volume = this.volume;
    $$invalidate(13, volume);
  }
  function playbar_currentTime_binding(value) {
    currentTime = value;
    $$invalidate(9, currentTime), $$invalidate(11, ended), $$invalidate(56, loop), $$invalidate(8, videoElement);
  }
  function playbar_paused_binding(value) {
    paused = value;
    $$invalidate(12, paused);
  }
  function playbar_isScrubbing_binding(value) {
    isScrubbing = value;
    $$invalidate(17, isScrubbing);
  }
  function volumecontrol_volume_binding(value) {
    volume = value;
    $$invalidate(13, volume);
  }
  function bottomcontrols_isPointerOver_binding(value) {
    isPointerOverControls = value;
    $$invalidate(22, isPointerOverControls);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      videoPlayerElement = $$value;
      $$invalidate(18, videoPlayerElement);
    });
  }
  function idledetector_isIdle_binding(value) {
    isIdle = value;
    $$invalidate(16, isIdle);
  }
  function scrolldetector_isScrolling_binding(value) {
    isScrolling = value;
    $$invalidate(25, isScrolling);
  }
  function fullscreenmanager_isFullscreenEnabled_binding(value) {
    isFullscreenEnabled = value;
    $$invalidate(23, isFullscreenEnabled);
  }
  function fullscreenmanager_isFullscreen_binding(value) {
    isFullscreen2 = value;
    $$invalidate(24, isFullscreen2);
  }
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("poster" in $$props2)
      $$invalidate(2, poster = $$props2.poster);
    if ("source" in $$props2)
      $$invalidate(46, source = $$props2.source);
    if ("controlsHeight" in $$props2)
      $$invalidate(47, controlsHeight = $$props2.controlsHeight);
    if ("trackHeight" in $$props2)
      $$invalidate(48, trackHeight = $$props2.trackHeight);
    if ("thumbSize" in $$props2)
      $$invalidate(49, thumbSize = $$props2.thumbSize);
    if ("centerIconSize" in $$props2)
      $$invalidate(50, centerIconSize = $$props2.centerIconSize);
    if ("playerBgColor" in $$props2)
      $$invalidate(3, playerBgColor = $$props2.playerBgColor);
    if ("color" in $$props2)
      $$invalidate(51, color = $$props2.color);
    if ("focusColor" in $$props2)
      $$invalidate(52, focusColor = $$props2.focusColor);
    if ("barsBgColor" in $$props2)
      $$invalidate(53, barsBgColor = $$props2.barsBgColor);
    if ("iconColor" in $$props2)
      $$invalidate(4, iconColor = $$props2.iconColor);
    if ("bufferedColor" in $$props2)
      $$invalidate(54, bufferedColor = $$props2.bufferedColor);
    if ("chunkBars" in $$props2)
      $$invalidate(55, chunkBars = $$props2.chunkBars);
    if ("borderRadius" in $$props2)
      $$invalidate(5, borderRadius = $$props2.borderRadius);
    if ("loop" in $$props2)
      $$invalidate(56, loop = $$props2.loop);
    if ("skipSeconds" in $$props2)
      $$invalidate(57, skipSeconds = $$props2.skipSeconds);
    if ("aspectRatio" in $$props2)
      $$invalidate(6, aspectRatio = $$props2.aspectRatio);
    if ("controlsOnPause" in $$props2)
      $$invalidate(58, controlsOnPause = $$props2.controlsOnPause);
    if ("timeDisplay" in $$props2)
      $$invalidate(7, timeDisplay = $$props2.timeDisplay);
  };
  $$self.$capture_state = () => ({
    currentVideo,
    onPlay,
    setContext,
    writable,
    uid,
    preloadImage,
    prepareVideoSources,
    Poster: Poster_default,
    Controls: Controls_default,
    CenterIcons: CenterIcons_default,
    BottomControls: BottomControls_default,
    Playbar: Playbar_default,
    PlayPauseButton: PlayPauseButton_default,
    VolumeButton: VolumeButton_default,
    VolumeControl: VolumeControl_default,
    FullscreenButton: FullscreenButton_default,
    FullscreenManager: FullscreenManager_default,
    IdleDetector: IdleDetector_default,
    ScrollDetector: ScrollDetector_default,
    Spinner: Spinner_default,
    Time: Time_default,
    width,
    height,
    poster,
    source,
    controlsHeight,
    trackHeight,
    thumbSize,
    centerIconSize,
    playerBgColor,
    color,
    focusColor,
    barsBgColor,
    iconColor,
    bufferedColor,
    chunkBars,
    borderRadius,
    loop,
    skipSeconds,
    aspectRatio,
    controlsOnPause,
    timeDisplay,
    config,
    videoPlayerElement,
    videoElement,
    currentTime,
    duration,
    buffered,
    played,
    seeking,
    ended,
    paused,
    volume,
    muteVolume,
    isVideoData,
    isPointerOverVideo,
    isPointerOverControls,
    isBuffering,
    isFullscreenEnabled,
    isFullscreen: isFullscreen2,
    isIdle,
    isScrolling,
    isScrubbing,
    isKeyDown,
    onVideoLoadedData,
    onVideoPlaying,
    onVideoWaiting,
    onPlayerPointerOver,
    onPlayerPointerOut,
    onPlayerPointerUp,
    onWindowKeyDown,
    onWindowKeyUp,
    timeJump,
    onFullscreenButtonPointerUp,
    onPlaybarPointerUp,
    onPlayPauseButtonPointerUp,
    onVolumeButtonPointerUp,
    togglePause,
    muted,
    _skipSeconds,
    isBottomControlsVisible,
    isCenterIconVisibile,
    isSpinnerVisible,
    isPosterVisible,
    _sources,
    $config
  });
  $$self.$inject_state = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("poster" in $$props2)
      $$invalidate(2, poster = $$props2.poster);
    if ("source" in $$props2)
      $$invalidate(46, source = $$props2.source);
    if ("controlsHeight" in $$props2)
      $$invalidate(47, controlsHeight = $$props2.controlsHeight);
    if ("trackHeight" in $$props2)
      $$invalidate(48, trackHeight = $$props2.trackHeight);
    if ("thumbSize" in $$props2)
      $$invalidate(49, thumbSize = $$props2.thumbSize);
    if ("centerIconSize" in $$props2)
      $$invalidate(50, centerIconSize = $$props2.centerIconSize);
    if ("playerBgColor" in $$props2)
      $$invalidate(3, playerBgColor = $$props2.playerBgColor);
    if ("color" in $$props2)
      $$invalidate(51, color = $$props2.color);
    if ("focusColor" in $$props2)
      $$invalidate(52, focusColor = $$props2.focusColor);
    if ("barsBgColor" in $$props2)
      $$invalidate(53, barsBgColor = $$props2.barsBgColor);
    if ("iconColor" in $$props2)
      $$invalidate(4, iconColor = $$props2.iconColor);
    if ("bufferedColor" in $$props2)
      $$invalidate(54, bufferedColor = $$props2.bufferedColor);
    if ("chunkBars" in $$props2)
      $$invalidate(55, chunkBars = $$props2.chunkBars);
    if ("borderRadius" in $$props2)
      $$invalidate(5, borderRadius = $$props2.borderRadius);
    if ("loop" in $$props2)
      $$invalidate(56, loop = $$props2.loop);
    if ("skipSeconds" in $$props2)
      $$invalidate(57, skipSeconds = $$props2.skipSeconds);
    if ("aspectRatio" in $$props2)
      $$invalidate(6, aspectRatio = $$props2.aspectRatio);
    if ("controlsOnPause" in $$props2)
      $$invalidate(58, controlsOnPause = $$props2.controlsOnPause);
    if ("timeDisplay" in $$props2)
      $$invalidate(7, timeDisplay = $$props2.timeDisplay);
    if ("videoPlayerElement" in $$props2)
      $$invalidate(18, videoPlayerElement = $$props2.videoPlayerElement);
    if ("videoElement" in $$props2)
      $$invalidate(8, videoElement = $$props2.videoElement);
    if ("currentTime" in $$props2)
      $$invalidate(9, currentTime = $$props2.currentTime);
    if ("duration" in $$props2)
      $$invalidate(19, duration = $$props2.duration);
    if ("buffered" in $$props2)
      $$invalidate(20, buffered = $$props2.buffered);
    if ("played" in $$props2)
      $$invalidate(21, played = $$props2.played);
    if ("seeking" in $$props2)
      $$invalidate(10, seeking = $$props2.seeking);
    if ("ended" in $$props2)
      $$invalidate(11, ended = $$props2.ended);
    if ("paused" in $$props2)
      $$invalidate(12, paused = $$props2.paused);
    if ("volume" in $$props2)
      $$invalidate(13, volume = $$props2.volume);
    if ("muteVolume" in $$props2)
      muteVolume = $$props2.muteVolume;
    if ("isVideoData" in $$props2)
      $$invalidate(14, isVideoData = $$props2.isVideoData);
    if ("isPointerOverVideo" in $$props2)
      $$invalidate(59, isPointerOverVideo = $$props2.isPointerOverVideo);
    if ("isPointerOverControls" in $$props2)
      $$invalidate(22, isPointerOverControls = $$props2.isPointerOverControls);
    if ("isBuffering" in $$props2)
      $$invalidate(15, isBuffering = $$props2.isBuffering);
    if ("isFullscreenEnabled" in $$props2)
      $$invalidate(23, isFullscreenEnabled = $$props2.isFullscreenEnabled);
    if ("isFullscreen" in $$props2)
      $$invalidate(24, isFullscreen2 = $$props2.isFullscreen);
    if ("isIdle" in $$props2)
      $$invalidate(16, isIdle = $$props2.isIdle);
    if ("isScrolling" in $$props2)
      $$invalidate(25, isScrolling = $$props2.isScrolling);
    if ("isScrubbing" in $$props2)
      $$invalidate(17, isScrubbing = $$props2.isScrubbing);
    if ("isKeyDown" in $$props2)
      isKeyDown = $$props2.isKeyDown;
    if ("muted" in $$props2)
      $$invalidate(26, muted = $$props2.muted);
    if ("_skipSeconds" in $$props2)
      _skipSeconds = $$props2._skipSeconds;
    if ("isBottomControlsVisible" in $$props2)
      $$invalidate(27, isBottomControlsVisible = $$props2.isBottomControlsVisible);
    if ("isCenterIconVisibile" in $$props2)
      $$invalidate(28, isCenterIconVisibile = $$props2.isCenterIconVisibile);
    if ("isSpinnerVisible" in $$props2)
      $$invalidate(29, isSpinnerVisible = $$props2.isSpinnerVisible);
    if ("isPosterVisible" in $$props2)
      $$invalidate(30, isPosterVisible = $$props2.isPosterVisible);
    if ("_sources" in $$props2)
      $$invalidate(31, _sources = $$props2._sources);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*source*/
    32768) {
      $:
        $$invalidate(31, _sources = prepareVideoSources(source));
    }
    if ($$self.$$.dirty[1] & /*skipSeconds*/
    67108864) {
      $:
        _skipSeconds = parseFloat(skipSeconds);
    }
    if ($$self.$$.dirty[1] & /*controlsHeight*/
    65536) {
      $:
        set_store_value(config, $config.controlsHeight = controlsHeight, $config);
    }
    if ($$self.$$.dirty[1] & /*thumbSize*/
    262144) {
      $:
        set_store_value(config, $config.thumbSize = thumbSize, $config);
    }
    if ($$self.$$.dirty[1] & /*trackHeight*/
    131072) {
      $:
        set_store_value(config, $config.trackHeight = trackHeight, $config);
    }
    if ($$self.$$.dirty[1] & /*centerIconSize*/
    524288) {
      $:
        set_store_value(config, $config.centerIconSize = centerIconSize, $config);
    }
    if ($$self.$$.dirty[1] & /*color*/
    1048576) {
      $:
        set_store_value(config, $config.color = color, $config);
    }
    if ($$self.$$.dirty[0] & /*playerBgColor*/
    8) {
      $:
        set_store_value(config, $config.playerBgColor = playerBgColor, $config);
    }
    if ($$self.$$.dirty[1] & /*focusColor*/
    2097152) {
      $:
        set_store_value(config, $config.focusColor = focusColor, $config);
    }
    if ($$self.$$.dirty[1] & /*barsBgColor*/
    4194304) {
      $:
        set_store_value(config, $config.barsBgColor = barsBgColor, $config);
    }
    if ($$self.$$.dirty[0] & /*iconColor*/
    16) {
      $:
        set_store_value(config, $config.iconColor = iconColor, $config);
    }
    if ($$self.$$.dirty[1] & /*bufferedColor*/
    8388608) {
      $:
        set_store_value(config, $config.bufferedColor = bufferedColor, $config);
    }
    if ($$self.$$.dirty[1] & /*chunkBars*/
    16777216) {
      $:
        set_store_value(config, $config.chunkBars = chunkBars, $config);
    }
    if ($$self.$$.dirty[1] & /*loop*/
    33554432) {
      $:
        set_store_value(config, $config.loop = loop, $config);
    }
    if ($$self.$$.dirty[0] & /*borderRadius*/
    32) {
      $:
        set_store_value(config, $config.borderRadius = borderRadius, $config);
    }
    if ($$self.$$.dirty[1] & /*controlsOnPause*/
    134217728) {
      $:
        set_store_value(config, $config.controlsOnPause = controlsOnPause, $config);
    }
    if ($$self.$$.dirty[0] & /*timeDisplay*/
    128) {
      $:
        set_store_value(config, $config.timeDisplay = timeDisplay, $config);
    }
    if ($$self.$$.dirty[0] & /*volume*/
    8192) {
      $:
        $$invalidate(26, muted = volume == 0);
    }
    if ($$self.$$.dirty[0] & /*ended, videoElement*/
    2304 | $$self.$$.dirty[1] & /*loop*/
    33554432) {
      $: {
        if (ended) {
          $$invalidate(9, currentTime = 0);
          if (loop)
            videoElement.play();
        }
      }
    }
    if ($$self.$$.dirty[0] & /*isVideoData, paused, currentTime*/
    20992) {
      $:
        $$invalidate(30, isPosterVisible = !isVideoData || paused && currentTime == 0);
    }
    if ($$self.$$.dirty[0] & /*isVideoData, paused, isIdle*/
    86016 | $$self.$$.dirty[1] & /*controlsOnPause, isPointerOverVideo*/
    402653184) {
      $:
        $$invalidate(27, isBottomControlsVisible = isVideoData && (paused && controlsOnPause || isPointerOverVideo && !isIdle));
    }
    if ($$self.$$.dirty[0] & /*seeking, isBuffering*/
    33792) {
      $:
        $$invalidate(29, isSpinnerVisible = seeking || isBuffering);
    }
    if ($$self.$$.dirty[0] & /*isVideoData, paused, isScrubbing*/
    151552) {
      $:
        $$invalidate(28, isCenterIconVisibile = !isVideoData || paused && !isScrubbing);
    }
  };
  return [
    width,
    height,
    poster,
    playerBgColor,
    iconColor,
    borderRadius,
    aspectRatio,
    timeDisplay,
    videoElement,
    currentTime,
    seeking,
    ended,
    paused,
    volume,
    isVideoData,
    isBuffering,
    isIdle,
    isScrubbing,
    videoPlayerElement,
    duration,
    buffered,
    played,
    isPointerOverControls,
    isFullscreenEnabled,
    isFullscreen2,
    isScrolling,
    muted,
    isBottomControlsVisible,
    isCenterIconVisibile,
    isSpinnerVisible,
    isPosterVisible,
    _sources,
    config,
    onVideoLoadedData,
    onVideoPlaying,
    onVideoWaiting,
    onPlayerPointerOver,
    onPlayerPointerOut,
    onPlayerPointerUp,
    onWindowKeyDown,
    onWindowKeyUp,
    onFullscreenButtonPointerUp,
    onPlaybarPointerUp,
    onPlayPauseButtonPointerUp,
    onVolumeButtonPointerUp,
    togglePause,
    source,
    controlsHeight,
    trackHeight,
    thumbSize,
    centerIconSize,
    color,
    focusColor,
    barsBgColor,
    bufferedColor,
    chunkBars,
    loop,
    skipSeconds,
    controlsOnPause,
    isPointerOverVideo,
    video_binding,
    video_timeupdate_handler,
    video_durationchange_handler,
    video_progress_handler,
    video_loadedmetadata_handler,
    video_seeking_seeked_handler,
    video_ended_handler,
    video_play_pause_handler,
    video_volumechange_handler,
    playbar_currentTime_binding,
    playbar_paused_binding,
    playbar_isScrubbing_binding,
    volumecontrol_volume_binding,
    bottomcontrols_isPointerOver_binding,
    div_binding,
    idledetector_isIdle_binding,
    scrolldetector_isScrolling_binding,
    fullscreenmanager_isFullscreenEnabled_binding,
    fullscreenmanager_isFullscreen_binding
  ];
}
var VideoPlayerClient = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance24,
      create_fragment24,
      safe_not_equal,
      {
        width: 0,
        height: 1,
        poster: 2,
        source: 46,
        controlsHeight: 47,
        trackHeight: 48,
        thumbSize: 49,
        centerIconSize: 50,
        playerBgColor: 3,
        color: 51,
        focusColor: 52,
        barsBgColor: 53,
        iconColor: 4,
        bufferedColor: 54,
        chunkBars: 55,
        borderRadius: 5,
        loop: 56,
        skipSeconds: 57,
        aspectRatio: 6,
        controlsOnPause: 58,
        timeDisplay: 7
      },
      add_css17,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VideoPlayerClient",
      options,
      id: create_fragment24.name
    });
  }
  get width() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get poster() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set poster(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get source() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set source(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get controlsHeight() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set controlsHeight(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trackHeight() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trackHeight(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get thumbSize() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set thumbSize(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get centerIconSize() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set centerIconSize(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get playerBgColor() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playerBgColor(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focusColor() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set focusColor(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get barsBgColor() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set barsBgColor(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconColor() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconColor(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bufferedColor() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bufferedColor(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chunkBars() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chunkBars(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderRadius() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderRadius(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skipSeconds() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skipSeconds(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get aspectRatio() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set aspectRatio(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get controlsOnPause() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set controlsOnPause(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get timeDisplay() {
    throw new Error("<VideoPlayerClient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set timeDisplay(value) {
    throw new Error("<VideoPlayerClient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VideoPlayerClient_default = VideoPlayerClient;

// node_modules/svelte-video-player/src/VideoPlayerServer.svelte
var file18 = "node_modules/svelte-video-player/src/VideoPlayerServer.svelte";
function add_css18(target) {
  append_styles(target, "svelte-1sqfmr5", ".aspect.svelte-1sqfmr5{position:relative;width:100%;height:0;padding-top:100%;overflow:hidden;border-radius:8px;-webkit-mask-image:-webkit-radial-gradient(white, black);mask-image:-webkit-radial-gradient(white, black)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmlkZW9QbGF5ZXJTZXJ2ZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQU9FLHNCQUFRLENBQ04sUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsQ0FBQyxDQUNULFdBQVcsQ0FBRSxJQUFJLENBQ2pCLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLGFBQWEsQ0FBRSxHQUFHLENBRWxCLGtCQUFrQixDQUFFLHdCQUF3QixLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FDekQsVUFBVSxDQUFFLHdCQUF3QixLQUFLLENBQUMsQ0FBQyxLQUFLLENBQ2xEIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlZpZGVvUGxheWVyU2VydmVyLnN2ZWx0ZSJdfQ== */");
}
function create_fragment25(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "aspect svelte-1sqfmr5");
      set_style(
        div,
        "padding-top",
        /*aspectRatio*/
        ctx[2] * 100 + "%"
      );
      set_style(
        div,
        "background-color",
        /*playerBgColor*/
        ctx[0]
      );
      set_style(
        div,
        "border-radius",
        /*borderRadius*/
        ctx[1]
      );
      add_location(div, file18, 20, 0, 453);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*aspectRatio*/
      4) {
        set_style(
          div,
          "padding-top",
          /*aspectRatio*/
          ctx2[2] * 100 + "%"
        );
      }
      if (dirty & /*playerBgColor*/
      1) {
        set_style(
          div,
          "background-color",
          /*playerBgColor*/
          ctx2[0]
        );
      }
      if (dirty & /*borderRadius*/
      2) {
        set_style(
          div,
          "border-radius",
          /*borderRadius*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VideoPlayerServer", slots, []);
  let { playerBgColor } = $$props;
  let { borderRadius } = $$props;
  let { aspectRatio } = $$props;
  $$self.$$.on_mount.push(function() {
    if (playerBgColor === void 0 && !("playerBgColor" in $$props || $$self.$$.bound[$$self.$$.props["playerBgColor"]])) {
      console.warn("<VideoPlayerServer> was created without expected prop 'playerBgColor'");
    }
    if (borderRadius === void 0 && !("borderRadius" in $$props || $$self.$$.bound[$$self.$$.props["borderRadius"]])) {
      console.warn("<VideoPlayerServer> was created without expected prop 'borderRadius'");
    }
    if (aspectRatio === void 0 && !("aspectRatio" in $$props || $$self.$$.bound[$$self.$$.props["aspectRatio"]])) {
      console.warn("<VideoPlayerServer> was created without expected prop 'aspectRatio'");
    }
  });
  const writable_props = ["playerBgColor", "borderRadius", "aspectRatio"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VideoPlayerServer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("playerBgColor" in $$props2)
      $$invalidate(0, playerBgColor = $$props2.playerBgColor);
    if ("borderRadius" in $$props2)
      $$invalidate(1, borderRadius = $$props2.borderRadius);
    if ("aspectRatio" in $$props2)
      $$invalidate(2, aspectRatio = $$props2.aspectRatio);
  };
  $$self.$capture_state = () => ({ playerBgColor, borderRadius, aspectRatio });
  $$self.$inject_state = ($$props2) => {
    if ("playerBgColor" in $$props2)
      $$invalidate(0, playerBgColor = $$props2.playerBgColor);
    if ("borderRadius" in $$props2)
      $$invalidate(1, borderRadius = $$props2.borderRadius);
    if ("aspectRatio" in $$props2)
      $$invalidate(2, aspectRatio = $$props2.aspectRatio);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [playerBgColor, borderRadius, aspectRatio];
}
var VideoPlayerServer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance25,
      create_fragment25,
      safe_not_equal,
      {
        playerBgColor: 0,
        borderRadius: 1,
        aspectRatio: 2
      },
      add_css18
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VideoPlayerServer",
      options,
      id: create_fragment25.name
    });
  }
  get playerBgColor() {
    throw new Error("<VideoPlayerServer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playerBgColor(value) {
    throw new Error("<VideoPlayerServer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderRadius() {
    throw new Error("<VideoPlayerServer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderRadius(value) {
    throw new Error("<VideoPlayerServer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get aspectRatio() {
    throw new Error("<VideoPlayerServer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set aspectRatio(value) {
    throw new Error("<VideoPlayerServer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VideoPlayerServer_default = VideoPlayerServer;

// node_modules/svelte-video-player/src/VideoPlayer.svelte
function create_else_block(ctx) {
  let videoplayerserver;
  let current;
  videoplayerserver = new VideoPlayerServer_default({
    props: {
      playerBgColor: (
        /*playerBgColor*/
        ctx[8]
      ),
      borderRadius: (
        /*borderRadius*/
        ctx[15]
      ),
      aspectRatio: (
        /*aspectRatio*/
        ctx[20]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(videoplayerserver.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(videoplayerserver, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const videoplayerserver_changes = {};
      if (dirty & /*playerBgColor*/
      256)
        videoplayerserver_changes.playerBgColor = /*playerBgColor*/
        ctx2[8];
      if (dirty & /*borderRadius*/
      32768)
        videoplayerserver_changes.borderRadius = /*borderRadius*/
        ctx2[15];
      if (dirty & /*aspectRatio*/
      1048576)
        videoplayerserver_changes.aspectRatio = /*aspectRatio*/
        ctx2[20];
      videoplayerserver.$set(videoplayerserver_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(videoplayerserver.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(videoplayerserver.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(videoplayerserver, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(60:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let videoplayerclient;
  let current;
  videoplayerclient = new VideoPlayerClient_default({
    props: {
      width: (
        /*width*/
        ctx[0]
      ),
      height: (
        /*height*/
        ctx[1]
      ),
      poster: (
        /*poster*/
        ctx[2]
      ),
      source: (
        /*source*/
        ctx[3]
      ),
      controlsHeight: (
        /*controlsHeight*/
        ctx[4]
      ),
      trackHeight: (
        /*trackHeight*/
        ctx[5]
      ),
      thumbSize: (
        /*thumbSize*/
        ctx[6]
      ),
      centerIconSize: (
        /*centerIconSize*/
        ctx[7]
      ),
      playerBgColor: (
        /*playerBgColor*/
        ctx[8]
      ),
      color: (
        /*color*/
        ctx[9]
      ),
      focusColor: (
        /*focusColor*/
        ctx[10]
      ),
      barsBgColor: (
        /*barsBgColor*/
        ctx[11]
      ),
      iconColor: (
        /*iconColor*/
        ctx[12]
      ),
      bufferedColor: (
        /*bufferedColor*/
        ctx[13]
      ),
      chunkBars: (
        /*chunkBars*/
        ctx[14]
      ),
      borderRadius: (
        /*borderRadius*/
        ctx[15]
      ),
      loop: (
        /*loop*/
        ctx[16]
      ),
      skipSeconds: (
        /*skipSeconds*/
        ctx[17]
      ),
      aspectRatio: (
        /*aspectRatio*/
        ctx[20]
      ),
      controlsOnPause: (
        /*controlsOnPause*/
        ctx[18]
      ),
      timeDisplay: (
        /*timeDisplay*/
        ctx[19]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(videoplayerclient.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(videoplayerclient, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const videoplayerclient_changes = {};
      if (dirty & /*width*/
      1)
        videoplayerclient_changes.width = /*width*/
        ctx2[0];
      if (dirty & /*height*/
      2)
        videoplayerclient_changes.height = /*height*/
        ctx2[1];
      if (dirty & /*poster*/
      4)
        videoplayerclient_changes.poster = /*poster*/
        ctx2[2];
      if (dirty & /*source*/
      8)
        videoplayerclient_changes.source = /*source*/
        ctx2[3];
      if (dirty & /*controlsHeight*/
      16)
        videoplayerclient_changes.controlsHeight = /*controlsHeight*/
        ctx2[4];
      if (dirty & /*trackHeight*/
      32)
        videoplayerclient_changes.trackHeight = /*trackHeight*/
        ctx2[5];
      if (dirty & /*thumbSize*/
      64)
        videoplayerclient_changes.thumbSize = /*thumbSize*/
        ctx2[6];
      if (dirty & /*centerIconSize*/
      128)
        videoplayerclient_changes.centerIconSize = /*centerIconSize*/
        ctx2[7];
      if (dirty & /*playerBgColor*/
      256)
        videoplayerclient_changes.playerBgColor = /*playerBgColor*/
        ctx2[8];
      if (dirty & /*color*/
      512)
        videoplayerclient_changes.color = /*color*/
        ctx2[9];
      if (dirty & /*focusColor*/
      1024)
        videoplayerclient_changes.focusColor = /*focusColor*/
        ctx2[10];
      if (dirty & /*barsBgColor*/
      2048)
        videoplayerclient_changes.barsBgColor = /*barsBgColor*/
        ctx2[11];
      if (dirty & /*iconColor*/
      4096)
        videoplayerclient_changes.iconColor = /*iconColor*/
        ctx2[12];
      if (dirty & /*bufferedColor*/
      8192)
        videoplayerclient_changes.bufferedColor = /*bufferedColor*/
        ctx2[13];
      if (dirty & /*chunkBars*/
      16384)
        videoplayerclient_changes.chunkBars = /*chunkBars*/
        ctx2[14];
      if (dirty & /*borderRadius*/
      32768)
        videoplayerclient_changes.borderRadius = /*borderRadius*/
        ctx2[15];
      if (dirty & /*loop*/
      65536)
        videoplayerclient_changes.loop = /*loop*/
        ctx2[16];
      if (dirty & /*skipSeconds*/
      131072)
        videoplayerclient_changes.skipSeconds = /*skipSeconds*/
        ctx2[17];
      if (dirty & /*aspectRatio*/
      1048576)
        videoplayerclient_changes.aspectRatio = /*aspectRatio*/
        ctx2[20];
      if (dirty & /*controlsOnPause*/
      262144)
        videoplayerclient_changes.controlsOnPause = /*controlsOnPause*/
        ctx2[18];
      if (dirty & /*timeDisplay*/
      524288)
        videoplayerclient_changes.timeDisplay = /*timeDisplay*/
        ctx2[19];
      videoplayerclient.$set(videoplayerclient_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(videoplayerclient.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(videoplayerclient.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(videoplayerclient, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(37:0) {#if isClient}",
    ctx
  });
  return block;
}
function create_fragment26(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block5, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*isClient*/
      ctx2[21]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let _width;
  let _height;
  let aspectRatio;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VideoPlayer", slots, []);
  let isClient = typeof window !== "undefined" ? true : false;
  let { width = 1920 } = $$props;
  let { height = 1080 } = $$props;
  let { poster = "" } = $$props;
  let { source = "" } = $$props;
  let { controlsHeight = "55px" } = $$props;
  let { trackHeight = "6px" } = $$props;
  let { thumbSize = "15px" } = $$props;
  let { centerIconSize = "60px" } = $$props;
  let { playerBgColor = "black" } = $$props;
  let { color = "#FF3E00" } = $$props;
  let { focusColor = "white" } = $$props;
  let { barsBgColor = "white" } = $$props;
  let { iconColor = "white" } = $$props;
  let { bufferedColor = "#FF9600" } = $$props;
  let { chunkBars = false } = $$props;
  let { borderRadius = "8px" } = $$props;
  let { loop = false } = $$props;
  let { skipSeconds = 5 } = $$props;
  let { controlsOnPause = true } = $$props;
  let { timeDisplay = false } = $$props;
  const writable_props = [
    "width",
    "height",
    "poster",
    "source",
    "controlsHeight",
    "trackHeight",
    "thumbSize",
    "centerIconSize",
    "playerBgColor",
    "color",
    "focusColor",
    "barsBgColor",
    "iconColor",
    "bufferedColor",
    "chunkBars",
    "borderRadius",
    "loop",
    "skipSeconds",
    "controlsOnPause",
    "timeDisplay"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VideoPlayer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("poster" in $$props2)
      $$invalidate(2, poster = $$props2.poster);
    if ("source" in $$props2)
      $$invalidate(3, source = $$props2.source);
    if ("controlsHeight" in $$props2)
      $$invalidate(4, controlsHeight = $$props2.controlsHeight);
    if ("trackHeight" in $$props2)
      $$invalidate(5, trackHeight = $$props2.trackHeight);
    if ("thumbSize" in $$props2)
      $$invalidate(6, thumbSize = $$props2.thumbSize);
    if ("centerIconSize" in $$props2)
      $$invalidate(7, centerIconSize = $$props2.centerIconSize);
    if ("playerBgColor" in $$props2)
      $$invalidate(8, playerBgColor = $$props2.playerBgColor);
    if ("color" in $$props2)
      $$invalidate(9, color = $$props2.color);
    if ("focusColor" in $$props2)
      $$invalidate(10, focusColor = $$props2.focusColor);
    if ("barsBgColor" in $$props2)
      $$invalidate(11, barsBgColor = $$props2.barsBgColor);
    if ("iconColor" in $$props2)
      $$invalidate(12, iconColor = $$props2.iconColor);
    if ("bufferedColor" in $$props2)
      $$invalidate(13, bufferedColor = $$props2.bufferedColor);
    if ("chunkBars" in $$props2)
      $$invalidate(14, chunkBars = $$props2.chunkBars);
    if ("borderRadius" in $$props2)
      $$invalidate(15, borderRadius = $$props2.borderRadius);
    if ("loop" in $$props2)
      $$invalidate(16, loop = $$props2.loop);
    if ("skipSeconds" in $$props2)
      $$invalidate(17, skipSeconds = $$props2.skipSeconds);
    if ("controlsOnPause" in $$props2)
      $$invalidate(18, controlsOnPause = $$props2.controlsOnPause);
    if ("timeDisplay" in $$props2)
      $$invalidate(19, timeDisplay = $$props2.timeDisplay);
  };
  $$self.$capture_state = () => ({
    VideoPlayerClient: VideoPlayerClient_default,
    VideoPlayerServer: VideoPlayerServer_default,
    isClient,
    width,
    height,
    poster,
    source,
    controlsHeight,
    trackHeight,
    thumbSize,
    centerIconSize,
    playerBgColor,
    color,
    focusColor,
    barsBgColor,
    iconColor,
    bufferedColor,
    chunkBars,
    borderRadius,
    loop,
    skipSeconds,
    controlsOnPause,
    timeDisplay,
    _width,
    _height,
    aspectRatio
  });
  $$self.$inject_state = ($$props2) => {
    if ("isClient" in $$props2)
      $$invalidate(21, isClient = $$props2.isClient);
    if ("width" in $$props2)
      $$invalidate(0, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("poster" in $$props2)
      $$invalidate(2, poster = $$props2.poster);
    if ("source" in $$props2)
      $$invalidate(3, source = $$props2.source);
    if ("controlsHeight" in $$props2)
      $$invalidate(4, controlsHeight = $$props2.controlsHeight);
    if ("trackHeight" in $$props2)
      $$invalidate(5, trackHeight = $$props2.trackHeight);
    if ("thumbSize" in $$props2)
      $$invalidate(6, thumbSize = $$props2.thumbSize);
    if ("centerIconSize" in $$props2)
      $$invalidate(7, centerIconSize = $$props2.centerIconSize);
    if ("playerBgColor" in $$props2)
      $$invalidate(8, playerBgColor = $$props2.playerBgColor);
    if ("color" in $$props2)
      $$invalidate(9, color = $$props2.color);
    if ("focusColor" in $$props2)
      $$invalidate(10, focusColor = $$props2.focusColor);
    if ("barsBgColor" in $$props2)
      $$invalidate(11, barsBgColor = $$props2.barsBgColor);
    if ("iconColor" in $$props2)
      $$invalidate(12, iconColor = $$props2.iconColor);
    if ("bufferedColor" in $$props2)
      $$invalidate(13, bufferedColor = $$props2.bufferedColor);
    if ("chunkBars" in $$props2)
      $$invalidate(14, chunkBars = $$props2.chunkBars);
    if ("borderRadius" in $$props2)
      $$invalidate(15, borderRadius = $$props2.borderRadius);
    if ("loop" in $$props2)
      $$invalidate(16, loop = $$props2.loop);
    if ("skipSeconds" in $$props2)
      $$invalidate(17, skipSeconds = $$props2.skipSeconds);
    if ("controlsOnPause" in $$props2)
      $$invalidate(18, controlsOnPause = $$props2.controlsOnPause);
    if ("timeDisplay" in $$props2)
      $$invalidate(19, timeDisplay = $$props2.timeDisplay);
    if ("_width" in $$props2)
      $$invalidate(22, _width = $$props2._width);
    if ("_height" in $$props2)
      $$invalidate(23, _height = $$props2._height);
    if ("aspectRatio" in $$props2)
      $$invalidate(20, aspectRatio = $$props2.aspectRatio);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*width*/
    1) {
      $:
        $$invalidate(22, _width = parseInt(width));
    }
    if ($$self.$$.dirty & /*height*/
    2) {
      $:
        $$invalidate(23, _height = parseInt(height));
    }
    if ($$self.$$.dirty & /*_height, _width*/
    12582912) {
      $:
        $$invalidate(20, aspectRatio = _height / _width);
    }
  };
  return [
    width,
    height,
    poster,
    source,
    controlsHeight,
    trackHeight,
    thumbSize,
    centerIconSize,
    playerBgColor,
    color,
    focusColor,
    barsBgColor,
    iconColor,
    bufferedColor,
    chunkBars,
    borderRadius,
    loop,
    skipSeconds,
    controlsOnPause,
    timeDisplay,
    aspectRatio,
    isClient,
    _width,
    _height
  ];
}
var VideoPlayer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, {
      width: 0,
      height: 1,
      poster: 2,
      source: 3,
      controlsHeight: 4,
      trackHeight: 5,
      thumbSize: 6,
      centerIconSize: 7,
      playerBgColor: 8,
      color: 9,
      focusColor: 10,
      barsBgColor: 11,
      iconColor: 12,
      bufferedColor: 13,
      chunkBars: 14,
      borderRadius: 15,
      loop: 16,
      skipSeconds: 17,
      controlsOnPause: 18,
      timeDisplay: 19
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VideoPlayer",
      options,
      id: create_fragment26.name
    });
  }
  get width() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get poster() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set poster(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get source() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set source(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get controlsHeight() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set controlsHeight(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trackHeight() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trackHeight(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get thumbSize() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set thumbSize(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get centerIconSize() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set centerIconSize(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get playerBgColor() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playerBgColor(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focusColor() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set focusColor(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get barsBgColor() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set barsBgColor(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconColor() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconColor(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bufferedColor() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bufferedColor(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chunkBars() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chunkBars(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderRadius() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderRadius(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skipSeconds() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skipSeconds(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get controlsOnPause() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set controlsOnPause(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get timeDisplay() {
    throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set timeDisplay(value) {
    throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VideoPlayer_default = VideoPlayer;
export {
  VideoPlayer_default as default
};
/*! Bundled license information:

svelte-video-player/src/libs/screenfull.js:
  (*!
   * screenfull
   * v5.1.0 - 2020-12-24
   * (c) Sindre Sorhus; MIT License
   *)

svelte-video-player/src/libs/throttle.js:
  (*!
   * just-throttle
   * Copyright (c) 2016 angus croll The MIT License (MIT)
   *)

svelte-video-player/src/libs/debounce.js:
  (*!
   * just-debounce-it
   * Copyright (c) 2016 angus croll The MIT License (MIT)
   *)
*/
//# sourceMappingURL=svelte-video-player.js.map
